<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ExpÃ©rience VR Mobile</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            max-width: 300px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-btn {
            padding: 15px 25px;
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .control-btn:hover, .control-btn:active {
            background: #e55a2b;
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: #4ecdc4;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .vr-mode canvas {
            transform: none;
        }

        #orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 24px;
            text-align: center;
        }

        #gyro-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            text-align: center;
            padding: 20px;
        }

        #debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            display: none;
        }

        @media (orientation: portrait) {
            #orientation-warning {
                display: flex;
            }
        }

        @media (orientation: landscape) {
            #orientation-warning {
                display: none;
            }
        }

        /* Styles pour le mode plein Ã©cran */
        :-webkit-full-screen {
            width: 100%;
            height: 100%;
        }

        :-moz-full-screen {
            width: 100%;
            height: 100%;
        }

        :fullscreen {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<div id="orientation-warning">
    <div>ðŸ“±</div>
    <h2>Tournez votre tÃ©lÃ©phone</h2>
    <p>Basculez en mode paysage pour la VR</p>
</div>

<div id="gyro-permission">
    <h2>ðŸ§­ Permission gyroscope</h2>
    <p>Autorisez l'accÃ¨s au gyroscope pour contrÃ´ler la camÃ©ra avec les mouvements de votre tÃªte</p>
    <button class="control-btn" onclick="requestGyroPermission()">Autoriser</button>
</div>

<div id="info">
    <h3>ðŸš€ VR Mobile - SHINECON G05 PRO</h3>
    <p>â€¢ Placez votre iPhone dans le casque</p>
    <p>â€¢ Activez le mode VR pour l'Ã©cran divisÃ©</p>
    <p>â€¢ Bougez la tÃªte pour regarder autour</p>
    <p>â€¢ Tapez pour sÃ©lectionner les objets</p>
</div>

<div id="debug-info">
    <div>Alpha: <span id="alpha">0</span>Â°</div>
    <div>Beta: <span id="beta">0</span>Â°</div>
    <div>Gamma: <span id="gamma">0</span>Â°</div>
    <div>Camera Y: <span id="camY">0</span>Â°</div>
    <div>Camera X: <span id="camX">0</span>Â°</div>
</div>

<div id="controls">
    <button id="vrToggle" class="control-btn">Mode VR</button>
    <button id="resetView" class="control-btn">Recentrer</button>
    <button id="fullscreen" class="control-btn">Plein Ã©cran</button>
    <button id="debugToggle" class="control-btn">Debug</button>
</div>

<div id="canvas-container"></div>

<script>
    // Configuration de base
    let scene, camera, renderer, effect;
    let cubes = [];
    let spheres = [];
    let particles = [];
    let raycaster = new THREE.Raycaster();
    let clock = new THREE.Clock();
    let mouse = new THREE.Vector2();

    // Variables pour VR mobile
    let isVRMode = false;
    let deviceOrientationEnabled = false;
    let initialOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let orientationSet = false;
    let debugMode = false;

    // ContrÃ´les gyroscope amÃ©liorÃ©s
    let controls = {
        alpha: 0,
        beta: 0,
        gamma: 0
    };

    // Variables pour la calibration
    let baseRotationY = 0;
    let baseRotationX = 0;

    // MatÃ©riaux et couleurs
    const colors = [0xff6b35, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xfeca57, 0xff9ff3, 0x54a0ff];

    init();
    animate();

    function init() {
        // ScÃ¨ne
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000010, 50, 200);

        // CamÃ©ra avec position initiale corrigÃ©e
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);
        camera.lookAt(0, 1.6, 0); // Regarder vers l'horizon

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limiter pour les performances
        renderer.setClearColor(0x000010);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Configuration des contrÃ´les
        setupControls();
        setupDeviceOrientation();

        // Ã‰clairage amÃ©liorÃ©
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // LumiÃ¨res colorÃ©es
        const light1 = new THREE.PointLight(0xff6b35, 1, 30);
        light1.position.set(-10, 5, -10);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x4ecdc4, 1, 30);
        light2.position.set(10, 5, 10);
        scene.add(light2);

        // CrÃ©ation du monde
        createFloatingCubes();
        createFloatingSpheres();
        createParticleSystem();
        createEnvironment();

        // Ã‰vÃ©nements
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('touchstart', onTouchStart);

        // Ã‰vÃ©nements pour le plein Ã©cran
        document.addEventListener('fullscreenchange', onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', onFullscreenChange);
        document.addEventListener('mozfullscreenchange', onFullscreenChange);

        // VÃ©rifier si on doit demander la permission gyroscope
        checkGyroPermission();
    }

    function setupControls() {
        const vrToggle = document.getElementById('vrToggle');
        const resetView = document.getElementById('resetView');
        const fullscreen = document.getElementById('fullscreen');
        const debugToggle = document.getElementById('debugToggle');

        vrToggle.addEventListener('click', toggleVRMode);
        resetView.addEventListener('click', resetCameraView);
        fullscreen.addEventListener('click', toggleFullscreen);
        debugToggle.addEventListener('click', toggleDebug);
    }

    function toggleDebug() {
        debugMode = !debugMode;
        const debugInfo = document.getElementById('debug-info');
        const debugToggle = document.getElementById('debugToggle');

        if (debugMode) {
            debugInfo.style.display = 'block';
            debugToggle.classList.add('active');
        } else {
            debugInfo.style.display = 'none';
            debugToggle.classList.remove('active');
        }
    }

    function checkGyroPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('gyro-permission').style.display = 'flex';
        } else {
            setupDeviceOrientation();
        }
    }

    function requestGyroPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        document.getElementById('gyro-permission').style.display = 'none';
                        setupDeviceOrientation();
                    } else {
                        alert('Permission gyroscope refusÃ©e. Les contrÃ´les de tÃªte ne fonctionneront pas.');
                        document.getElementById('gyro-permission').style.display = 'none';
                    }
                })
                .catch(console.error);
        } else {
            document.getElementById('gyro-permission').style.display = 'none';
            setupDeviceOrientation();
        }
    }

    function setupDeviceOrientation() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', onDeviceOrientation);
            deviceOrientationEnabled = true;
        }
    }

    function onDeviceOrientation(event) {
        if (!deviceOrientationEnabled) return;

        // Calibrage initial
        if (!orientationSet) {
            initialOrientation = {
                alpha: event.alpha || 0,
                beta: event.beta || 0,
                gamma: event.gamma || 0
            };
            orientationSet = true;

            // DÃ©finir la rotation de base pour regarder vers l'horizon
            baseRotationY = 0;
            baseRotationX = 0;
        }

        // Calculer les angles relatifs avec correction
        const alpha = (event.alpha || 0) - initialOrientation.alpha;
        const beta = (event.beta || 0) - initialOrientation.beta;
        const gamma = (event.gamma || 0) - initialOrientation.gamma;

        controls.alpha = alpha;
        controls.beta = beta;
        controls.gamma = gamma;

        // Mise Ã  jour du debug
        if (debugMode) {
            document.getElementById('alpha').textContent = alpha.toFixed(1);
            document.getElementById('beta').textContent = beta.toFixed(1);
            document.getElementById('gamma').textContent = gamma.toFixed(1);
        }

        updateCameraFromOrientation();
    }

    function updateCameraFromOrientation() {
        if (!deviceOrientationEnabled) return;

        // Convertir les angles en radians avec corrections
        const alpha = controls.alpha * Math.PI / 180;
        const beta = controls.beta * Math.PI / 180;
        const gamma = controls.gamma * Math.PI / 180;

        // Appliquer la rotation Ã  la camÃ©ra avec corrections pour mobile VR
        camera.rotation.order = 'YXZ';

        // Correction pour l'axe Y (rotation horizontale)
        camera.rotation.y = -alpha + baseRotationY;

        // Correction pour l'axe X (rotation verticale) - inverser et limiter
        const correctedBeta = Math.max(-Math.PI/3, Math.min(Math.PI/3, -beta + baseRotationX));
        camera.rotation.x = correctedBeta;

        // Rotation Z pour l'inclinaison (optionnel, peut Ãªtre dÃ©sactivÃ© pour plus de confort)
        camera.rotation.z = gamma * 0.1; // RÃ©duire l'effet de l'inclinaison

        // Mise Ã  jour du debug
        if (debugMode) {
            document.getElementById('camY').textContent = (camera.rotation.y * 180 / Math.PI).toFixed(1);
            document.getElementById('camX').textContent = (camera.rotation.x * 180 / Math.PI).toFixed(1);
        }
    }

    function toggleVRMode() {
        const vrToggle = document.getElementById('vrToggle');
        const info = document.getElementById('info');
        const controls = document.getElementById('controls');

        isVRMode = !isVRMode;

        if (isVRMode) {
            // Activer le mode VR (Ã©cran divisÃ©)
            vrToggle.textContent = 'Mode Normal';
            vrToggle.classList.add('active');
            info.style.display = 'none';
            controls.style.display = 'none';

            // Forcer le plein Ã©cran en mode VR
            if (!document.fullscreenElement) {
                requestFullscreen();
            }

            // Verrouiller l'orientation en paysage si possible
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(console.log);
            }
        } else {
            // DÃ©sactiver le mode VR
            vrToggle.textContent = 'Mode VR';
            vrToggle.classList.remove('active');
            info.style.display = 'block';
            controls.style.display = 'flex';

            // Retour au rendu normal
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false);
        }
    }

    function renderStereo() {
        if (!isVRMode) {
            renderer.render(scene, camera);
            return;
        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        const eyeSeparation = 0.032; // Distance inter-pupillaire / 2

        renderer.setScissorTest(true);

        // Sauvegarder la position originale
        const originalX = camera.position.x;

        // Å’il gauche
        renderer.setScissor(0, 0, width / 2, height);
        renderer.setViewport(0, 0, width / 2, height);
        camera.position.x = originalX - eyeSeparation;
        renderer.render(scene, camera);

        // Å’il droit
        renderer.setScissor(width / 2, 0, width / 2, height);
        renderer.setViewport(width / 2, 0, width / 2, height);
        camera.position.x = originalX + eyeSeparation;
        renderer.render(scene, camera);

        // Restaurer la position originale
        camera.position.x = originalX;

        renderer.setScissorTest(false);
    }

    function resetCameraView() {
        // RÃ©initialiser la position et rotation de la camÃ©ra
        camera.position.set(0, 1.6, 5);
        camera.rotation.set(0, 0, 0);

        // Recalibrer l'orientation
        orientationSet = false;
        baseRotationY = 0;
        baseRotationX = 0;

        console.log('Vue rÃ©initialisÃ©e');
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
            requestFullscreen();
        } else {
            exitFullscreen();
        }
    }

    function requestFullscreen() {
        const element = document.documentElement;

        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
    }

    function exitFullscreen() {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    }

    function onFullscreenChange() {
        const fullscreenBtn = document.getElementById('fullscreen');

        if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
            fullscreenBtn.textContent = 'Quitter';
            fullscreenBtn.classList.add('active');
        } else {
            fullscreenBtn.textContent = 'Plein Ã©cran';
            fullscreenBtn.classList.remove('active');
        }

        // Redimensionner le renderer
        onWindowResize();
    }

    function createFloatingCubes() {
        for (let i = 0; i < 15; i++) {
            const geometry = new THREE.BoxGeometry(
                Math.random() * 2 + 0.5,
                Math.random() * 2 + 0.5,
                Math.random() * 2 + 0.5
            );

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.8
            });

            const cube = new THREE.Mesh(geometry, material);

            cube.position.set(
                (Math.random() - 0.5) * 30,
                Math.random() * 10 + 2,
                (Math.random() - 0.5) * 30
            );

            cube.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            cube.userData = {
                originalColor: material.color.getHex(),
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                floatSpeed: Math.random() * 0.02 + 0.01,
                floatOffset: Math.random() * Math.PI * 2
            };

            cubes.push(cube);
            scene.add(cube);
        }
    }

    function createFloatingSpheres() {
        for (let i = 0; i < 12; i++) {
            const geometry = new THREE.SphereGeometry(Math.random() * 1.5 + 0.3, 16, 16);

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.7,
                emissive: colors[Math.floor(Math.random() * colors.length)],
                emissiveIntensity: 0.1
            });

            const sphere = new THREE.Mesh(geometry, material);

            sphere.position.set(
                (Math.random() - 0.5) * 25,
                Math.random() * 8 + 3,
                (Math.random() - 0.5) * 25
            );

            sphere.userData = {
                originalColor: material.color.getHex(),
                originalEmissive: material.emissive.getHex(),
                floatSpeed: Math.random() * 0.03 + 0.01,
                floatOffset: Math.random() * Math.PI * 2,
                pulseSpeed: Math.random() * 0.05 + 0.02
            };

            spheres.push(sphere);
            scene.add(sphere);
        }
    }

    function createParticleSystem() {
        const particleCount = 200;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 100;
            positions[i + 1] = Math.random() * 50;
            positions[i + 2] = (Math.random() - 0.5) * 100;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0x4ecdc4,
            size: 0.5,
            transparent: true,
            opacity: 0.6
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        particles.push(particleSystem);
    }

    function createEnvironment() {
        // Sol avec grille
        const gridGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
        const gridMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });

        const grid = new THREE.Mesh(gridGeometry, gridMaterial);
        grid.rotation.x = -Math.PI / 2;
        grid.position.y = 0;
        scene.add(grid);

        // Ciel Ã©toilÃ©
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(1000 * 3);

        for (let i = 0; i < 1000 * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 200;
            starPositions[i + 1] = Math.random() * 100 + 20;
            starPositions[i + 2] = (Math.random() - 0.5) * 200;
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));

        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1,
            transparent: true,
            opacity: 0.8
        });

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        const time = clock.getElapsedTime();

        // Animation des cubes
        cubes.forEach((cube, index) => {
            const userData = cube.userData;

            cube.rotation.x += userData.rotationSpeed.x;
            cube.rotation.y += userData.rotationSpeed.y;
            cube.rotation.z += userData.rotationSpeed.z;

            cube.position.y += Math.sin(time * userData.floatSpeed + userData.floatOffset) * 0.01;
        });

        // Animation des sphÃ¨res
        spheres.forEach((sphere, index) => {
            const userData = sphere.userData;

            sphere.position.y += Math.sin(time * userData.floatSpeed + userData.floatOffset) * 0.015;
            sphere.position.x += Math.cos(time * userData.floatSpeed * 0.5) * 0.005;

            const scale = 1 + Math.sin(time * userData.pulseSpeed) * 0.1;
            sphere.scale.setScalar(scale);
        });

        // Animation des particules
        particles.forEach(particleSystem => {
            particleSystem.rotation.y += 0.001;
            const positions = particleSystem.geometry.attributes.position.array;

            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(time + positions[i] * 0.01) * 0.01;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
        });

        // Rendu stÃ©rÃ©oscopique ou normal
        renderStereo();
    }

    function onMouseClick(event) {
        if (isVRMode) return;

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        checkIntersection();
    }

    function onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            checkIntersection();
        }
    }

    function checkIntersection() {
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects([...cubes, ...spheres]);

        if (intersects.length > 0) {
            const object = intersects[0].object;

            // Animation de sÃ©lection
            object.material.color.setHex(0xffffff);
            object.scale.setScalar(1.3);

            setTimeout(() => {
                object.material.color.setHex(object.userData.originalColor);
                object.scale.setScalar(1);
            }, 500);
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>