<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Exp√©rience VR Mobile</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            touch-action: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            max-width: 300px;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-btn {
            padding: 15px 25px;
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .control-btn:hover, .control-btn:active {
            background: #e55a2b;
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: #4ecdc4;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .vr-mode canvas {
            transform: none;
        }

        #orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 24px;
            text-align: center;
        }

        #gyro-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            text-align: center;
            padding: 20px;
        }

        @media (orientation: portrait) {
            #orientation-warning {
                display: flex;
            }
        }

        @media (orientation: landscape) {
            #orientation-warning {
                display: none;
            }
        }
    </style>
</head>
<body>
<div id="orientation-warning">
    <div>üì±</div>
    <h2>Tournez votre t√©l√©phone</h2>
    <p>Basculez en mode paysage pour la VR</p>
</div>

<div id="gyro-permission">
    <h2>üß≠ Permission gyroscope</h2>
    <p>Autorisez l'acc√®s au gyroscope pour contr√¥ler la cam√©ra avec les mouvements de votre t√™te</p>
    <button class="control-btn" onclick="requestGyroPermission()">Autoriser</button>
</div>

<div id="info">
    <h3>üöÄ VR Mobile - SHINECON G05 PRO</h3>
    <p>‚Ä¢ Placez votre iPhone dans le casque</p>
    <p>‚Ä¢ Activez le mode VR pour l'√©cran divis√©</p>
    <p>‚Ä¢ Bougez la t√™te pour regarder autour</p>
    <p>‚Ä¢ Tapez pour s√©lectionner les objets</p>
</div>

<div id="controls">
    <button id="vrToggle" class="control-btn">Mode VR</button>
    <button id="resetView" class="control-btn">Recentrer</button>
    <button id="fullscreen" class="control-btn">Plein √©cran</button>
</div>

<div id="canvas-container"></div>

<script>
    // Configuration de base
    let scene, camera, renderer, effect;
    let cubes = [];
    let spheres = [];
    let particles = [];
    let raycaster = new THREE.Raycaster();
    let clock = new THREE.Clock();
    let mouse = new THREE.Vector2();

    // Variables pour VR mobile
    let isVRMode = false;
    let deviceOrientationEnabled = false;
    let initialOrientation = { alpha: 0, beta: 0, gamma: 0 };
    let orientationSet = false;

    // Contr√¥les gyroscope
    let controls = {
        alpha: 0,
        beta: 0,
        gamma: 0
    };

    // Mat√©riaux et couleurs
    const colors = [0xff6b35, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xfeca57, 0xff9ff3, 0x54a0ff];

    init();
    animate();

    function init() {
        // Sc√®ne
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000010, 50, 200);

        // Cam√©ra
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000010);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Configuration des contr√¥les
        setupControls();
        setupDeviceOrientation();

        // √âclairage
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        scene.add(directionalLight);

        // Lumi√®res color√©es
        const light1 = new THREE.PointLight(0xff6b35, 1, 30);
        light1.position.set(-10, 5, -10);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x4ecdc4, 1, 30);
        light2.position.set(10, 5, 10);
        scene.add(light2);

        // Cr√©ation du monde
        createFloatingCubes();
        createFloatingSpheres();
        createParticleSystem();
        createEnvironment();

        // √âv√©nements
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('touchstart', onTouchStart);

        // V√©rifier si on doit demander la permission gyroscope
        checkGyroPermission();
    }

    function setupControls() {
        const vrToggle = document.getElementById('vrToggle');
        const resetView = document.getElementById('resetView');
        const fullscreen = document.getElementById('fullscreen');

        vrToggle.addEventListener('click', toggleVRMode);
        resetView.addEventListener('click', resetCameraView);
        fullscreen.addEventListener('click', toggleFullscreen);
    }

    function checkGyroPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('gyro-permission').style.display = 'flex';
        } else {
            setupDeviceOrientation();
        }
    }

    function requestGyroPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        document.getElementById('gyro-permission').style.display = 'none';
                        setupDeviceOrientation();
                    } else {
                        alert('Permission gyroscope refus√©e. Les contr√¥les de t√™te ne fonctionneront pas.');
                        document.getElementById('gyro-permission').style.display = 'none';
                    }
                })
                .catch(console.error);
        } else {
            document.getElementById('gyro-permission').style.display = 'none';
            setupDeviceOrientation();
        }
    }

    function setupDeviceOrientation() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', onDeviceOrientation);
            deviceOrientationEnabled = true;
        }
    }

    function onDeviceOrientation(event) {
        if (!deviceOrientationEnabled) return;

        // Calibrage initial
        if (!orientationSet) {
            initialOrientation = {
                alpha: event.alpha || 0,
                beta: event.beta || 0,
                gamma: event.gamma || 0
            };
            orientationSet = true;
        }

        // Calculer les angles relatifs
        controls.alpha = (event.alpha || 0) - initialOrientation.alpha;
        controls.beta = (event.beta || 0) - initialOrientation.beta;
        controls.gamma = (event.gamma || 0) - initialOrientation.gamma;

        updateCameraFromOrientation();
    }

    function updateCameraFromOrientation() {
        if (!deviceOrientationEnabled) return;

        // Convertir les angles en radians
        const alpha = controls.alpha * Math.PI / 180;
        const beta = controls.beta * Math.PI / 180;
        const gamma = controls.gamma * Math.PI / 180;

        // Appliquer la rotation √† la cam√©ra
        camera.rotation.order = 'YXZ';
        camera.rotation.y = -alpha;
        camera.rotation.x = -beta;
        camera.rotation.z = gamma;
    }

    function toggleVRMode() {
        const vrToggle = document.getElementById('vrToggle');
        const info = document.getElementById('info');
        const controls = document.getElementById('controls');

        isVRMode = !isVRMode;

        if (isVRMode) {
            // Activer le mode VR (√©cran divis√©)
            vrToggle.textContent = 'Mode Normal';
            vrToggle.classList.add('active');
            info.style.display = 'none';
            controls.style.display = 'none';

            // Cr√©er l'effet st√©r√©oscopique
            createStereoEffect();

            // Forcer le plein √©cran
            requestFullscreen();
        } else {
            // D√©sactiver le mode VR
            vrToggle.textContent = 'Mode VR';
            vrToggle.classList.remove('active');
            info.style.display = 'block';
            controls.style.display = 'flex';

            // Retour au rendu normal
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setScissorTest(false);
        }
    }

    function createStereoEffect() {
        // Distance inter-pupillaire (IPD) typique
        const eyeSeparation = 0.064;

        renderer.setScissorTest(true);

        // Configurer pour le rendu st√©r√©oscopique
        const width = window.innerWidth;
        const height = window.innerHeight;

        renderer.setSize(width, height);
    }

    function renderStereo() {
        if (!isVRMode) {
            renderer.render(scene, camera);
            return;
        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        const eyeSeparation = 0.032; // Moiti√© de l'IPD

        renderer.setScissorTest(true);

        // ≈íil gauche
        renderer.setScissor(0, 0, width / 2, height);
        renderer.setViewport(0, 0, width / 2, height);

        camera.position.x -= eyeSeparation;
        renderer.render(scene, camera);

        // ≈íil droit
        renderer.setScissor(width / 2, 0, width / 2, height);
        renderer.setViewport(width / 2, 0, width / 2, height);

        camera.position.x += eyeSeparation * 2;
        renderer.render(scene, camera);

        // Restaurer la position
        camera.position.x -= eyeSeparation;

        renderer.setScissorTest(false);
    }

    function resetCameraView() {
        camera.position.set(0, 1.6, 5);
        camera.rotation.set(0, 0, 0);

        // Recalibrer l'orientation
        orientationSet = false;
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            requestFullscreen();
        } else {
            document.exitFullscreen();
        }
    }

    function requestFullscreen() {
        const element = document.documentElement;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        }
    }

    function createFloatingCubes() {
        for (let i = 0; i < 15; i++) {
            const geometry = new THREE.BoxGeometry(
                Math.random() * 2 + 0.5,
                Math.random() * 2 + 0.5,
                Math.random() * 2 + 0.5
            );

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.8
            });

            const cube = new THREE.Mesh(geometry, material);

            cube.position.set(
                (Math.random() - 0.5) * 30,
                Math.random() * 10 + 2,
                (Math.random() - 0.5) * 30
            );

            cube.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            cube.userData = {
                originalColor: material.color.getHex(),
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                floatSpeed: Math.random() * 0.02 + 0.01,
                floatOffset: Math.random() * Math.PI * 2
            };

            cubes.push(cube);
            scene.add(cube);
        }
    }

    function createFloatingSpheres() {
        for (let i = 0; i < 12; i++) {
            const geometry = new THREE.SphereGeometry(Math.random() * 1.5 + 0.3, 16, 16);

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.7,
                emissive: colors[Math.floor(Math.random() * colors.length)],
                emissiveIntensity: 0.1
            });

            const sphere = new THREE.Mesh(geometry, material);

            sphere.position.set(
                (Math.random() - 0.5) * 25,
                Math.random() * 8 + 3,
                (Math.random() - 0.5) * 25
            );

            sphere.userData = {
                originalColor: material.color.getHex(),
                originalEmissive: material.emissive.getHex(),
                floatSpeed: Math.random() * 0.03 + 0.01,
                floatOffset: Math.random() * Math.PI * 2,
                pulseSpeed: Math.random() * 0.05 + 0.02
            };

            spheres.push(sphere);
            scene.add(sphere);
        }
    }

    function createParticleSystem() {
        const particleCount = 200;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 100;
            positions[i + 1] = Math.random() * 50;
            positions[i + 2] = (Math.random() - 0.5) * 100;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0x4ecdc4,
            size: 0.5,
            transparent: true,
            opacity: 0.6
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        particles.push(particleSystem);
    }

    function createEnvironment() {
        // Sol avec grille
        const gridGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
        const gridMaterial = new THREE.MeshBasicMaterial({
            color: 0x333333,
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });

        const grid = new THREE.Mesh(gridGeometry, gridMaterial);
        grid.rotation.x = -Math.PI / 2;
        grid.position.y = 0;
        scene.add(grid);

        // Ciel √©toil√©
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(1000 * 3);

        for (let i = 0; i < 1000 * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 200;
            starPositions[i + 1] = Math.random() * 100 + 20;
            starPositions[i + 2] = (Math.random() - 0.5) * 200;
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));

        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1,
            transparent: true,
            opacity: 0.8
        });

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
    }

    function render() {
        const time = clock.getElapsedTime();

        // Animation des cubes
        cubes.forEach((cube, index) => {
            const userData = cube.userData;

            cube.rotation.x += userData.rotationSpeed.x;
            cube.rotation.y += userData.rotationSpeed.y;
            cube.rotation.z += userData.rotationSpeed.z;

            cube.position.y += Math.sin(time * userData.floatSpeed + userData.floatOffset) * 0.01;
        });

        // Animation des sph√®res
        spheres.forEach((sphere, index) => {
            const userData = sphere.userData;

            sphere.position.y += Math.sin(time * userData.floatSpeed + userData.floatOffset) * 0.015;
            sphere.position.x += Math.cos(time * userData.floatSpeed * 0.5) * 0.005;

            const scale = 1 + Math.sin(time * userData.pulseSpeed) * 0.1;
            sphere.scale.setScalar(scale);
        });

        // Animation des particules
        particles.forEach(particleSystem => {
            particleSystem.rotation.y += 0.001;
            const positions = particleSystem.geometry.attributes.position.array;

            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(time + positions[i] * 0.01) * 0.01;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
        });

        // Rendu st√©r√©oscopique ou normal
        renderStereo();
    }

    function onMouseClick(event) {
        if (isVRMode) return;

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        checkIntersection();
    }

    function onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            checkIntersection();
        }
    }

    function checkIntersection() {
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects([...cubes, ...spheres]);

        if (intersects.length > 0) {
            const object = intersects[0].object;

            // Animation de s√©lection
            object.material.color.setHex(0xffffff);
            object.scale.setScalar(1.3);

            setTimeout(() => {
                object.material.color.setHex(object.userData.originalColor);
                object.scale.setScalar(1);
            }, 500);
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>