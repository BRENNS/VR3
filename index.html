<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Expérience VR Mobile Améliorée</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .control-button {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease;
            text-align: center;
        }

        .control-button:active {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(0.98);
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #status-vr, #status-gyro, #status-fullscreen {
            font-weight: bold;
        }

        #orientation-warning {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            font-size: 20px;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #movement-controls { /* NEW: Style for movement controls */
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #movement-controls .row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }
    </style>
</head>
<body>
<div id="info">
    <h3>Statut du jeu</h3>
    <p>VR Mode: <span id="status-vr">Désactivé</span></p>
    <p>Gyroscope: <span id="status-gyro">Non disponible</span></p>
    <p>Plein Écran: <span id="status-fullscreen">Non disponible</span></p>
    <p>Orientation: <span id="current-orientation">Chargement...</span></p>
    <p>FPS: <span id="fps-display">0</span></p>
    <p>Position: X:<span id="pos-x">0</span> Y:<span id="pos-y">0</span> Z:<span id="pos-z">0</span></p>
</div>

<div id="controls">
    <button id="toggleVR" class="control-button">Activer VR</button>
    <button id="requestGyro" class="control-button">Activer Gyroscope</button>
    <button id="calibrate" class="control-button">Calibrer Vue</button>
    <button id="toggleFullscreen" class="control-button">Plein Écran</button>
    <button id="resetView" class="control-button">Recentrer</button>
</div>

<div id="movement-controls">
    <div class="row">
        <button id="moveForward" class="control-button">▲ Avancer</button>
    </div>
    <div class="row">
        <button id="moveLeft" class="control-button">◀ Gauche</button>
        <button id="moveBackward" class="control-button">▼ Reculer</button>
        <button id="moveRight" class="control-button">▶ Droite</button>
    </div>
</div>

<div id="orientation-warning">
    <p>Veuillez tourner votre appareil en mode paysage pour une meilleure expérience VR.</p>
</div>

<script>
    // Three.js setup
    let scene, camera, renderer;
    let vrEnabled = false;
    let effect; // For StereoEffect
    let deviceOrientationEnabled = false;
    let screenOrientation = ''; // 'portrait' or 'landscape'

    // Gyroscope data
    const orientationData = {
        alpha: 0, beta: 0, gamma: 0,
        smoothAlpha: 0, smoothBeta: 0, smoothGamma: 0
    };
    const orientationCalibration = {
        alpha: 0, beta: 0, gamma: 0
    };

    // Parameters de lissage
    const SMOOTHING_FACTOR = 0.25;
    const ORIENTATION_THRESHOLD = 0.2;

    // FPS counter
    let lastFrameTime = 0;
    let frameCount = 0;
    let fps = 0;

    // Movement variables (NEW)
    const movementSpeed = 0.1; // Adjust as needed
    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;

    // Initialisation
    init();
    animate();
    setupControls();

    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0); // Position the camera at a typical "eye level"

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Add some basic objects to the scene
        addBox(0, 1, -5, 0xff0000); // Red box in front
        addBox(-3, 1, -3, 0x00ff00); // Green box left
        addBox(3, 1, -3, 0x0000ff);  // Blue box right
        addBox(0, 1, 5, 0xffff00); // Yellow box behind
        addBox(-5, 1, 0, 0xff00ff); // Magenta box left
        addBox(5, 1, 0, 0x00ffff);  // Cyan box right

        // Add a sphere
        const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
        const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xffa500 });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(0, 1.5, -10);
        scene.add(sphere);

        // Event listeners
        window.addEventListener('resize', onWindowResize, false);
        detectScreenOrientation(); // Initial orientation check
    }

    function addBox(x, y, z, color) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshLambertMaterial({ color: color });
        const box = new THREE.Mesh(geometry, material);
        box.position.set(x, y, z);
        scene.add(box);
    }

    function animate() {
        requestAnimationFrame(animate);

        const currentTime = performance.now();
        const deltaTime = (currentTime - lastFrameTime) / 1000; // in seconds
        lastFrameTime = currentTime;

        // FPS calculation
        frameCount++;
        if (frameCount % 60 === 0) { // Update FPS every 60 frames
            fps = Math.round(1 / deltaTime);
            document.getElementById('fps-display').textContent = fps;
            frameCount = 0;
        }

        // Update camera position based on movement flags (NEW)
        if (vrEnabled) { // Only allow movement in VR mode
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward); // Get camera's forward direction
            forward.y = 0; // Keep movement on the horizontal plane
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(camera.up, forward); // Get camera's right direction
            right.y = 0; // Keep movement on the horizontal plane
            right.normalize();

            if (moveForward) {
                camera.position.addScaledVector(forward, movementSpeed * deltaTime * 60); // Scale by deltaTime for smooth movement
            }
            if (moveBackward) {
                camera.position.addScaledVector(forward, -movementSpeed * deltaTime * 60);
            }
            if (moveLeft) {
                camera.position.addScaledVector(right, -movementSpeed * deltaTime * 60);
            }
            if (moveRight) {
                camera.position.addScaledVector(right, movementSpeed * deltaTime * 60);
            }
        }

        // Update position display
        document.getElementById('pos-x').textContent = camera.position.x.toFixed(2);
        document.getElementById('pos-y').textContent = camera.position.y.toFixed(2);
        document.getElementById('pos-z').textContent = camera.position.z.toFixed(2);

        // Render scene
        if (vrEnabled && effect) {
            effect.render(scene, camera);
        } else {
            renderer.render(scene, camera);
        }
    }

    function setupControls() {
        document.getElementById('toggleVR').addEventListener('click', toggleVR);
        document.getElementById('requestGyro').addEventListener('click', requestGyroPermission);
        document.getElementById('calibrate').addEventListener('click', calibrateOrientation);
        document.getElementById('toggleFullscreen').addEventListener('click', toggleFullscreen);
        document.getElementById('resetView').addEventListener('click', resetView);

        // Movement control listeners (NEW)
        document.getElementById('moveForward').addEventListener('touchstart', () => { moveForward = true; });
        document.getElementById('moveForward').addEventListener('touchend', () => { moveForward = false; });
        document.getElementById('moveBackward').addEventListener('touchstart', () => { moveBackward = true; });
        document.getElementById('moveBackward').addEventListener('touchend', () => { moveBackward = false; });
        document.getElementById('moveLeft').addEventListener('touchstart', () => { moveLeft = true; });
        document.getElementById('moveLeft').addEventListener('touchend', () => { moveLeft = false; });
        document.getElementById('moveRight').addEventListener('touchstart', () => { moveRight = true; });
        document.getElementById('moveRight').addEventListener('touchend', () => { moveRight = false; });

        // For desktop testing with keyboard (optional)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'w' || e.key === 'ArrowUp') moveForward = true;
            if (e.key === 's' || e.key === 'ArrowDown') moveBackward = true;
            if (e.key === 'a' || e.key === 'ArrowLeft') moveLeft = true;
            if (e.key === 'd' || e.key === 'ArrowRight') moveRight = true;
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'w' || e.key === 'ArrowUp') moveForward = false;
            if (e.key === 's' || e.key === 'ArrowDown') moveBackward = false;
            if (e.key === 'a' || e.key === 'ArrowLeft') moveLeft = false;
            if (e.key === 'd' || e.key === 'ArrowRight') moveRight = false;
        });
    }

    function requestGyroPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', onDeviceOrientation, true);
                        deviceOrientationEnabled = true;
                        updateGyroStatus(true);
                        console.log('✅ Accès gyroscope accordé.');
                    } else {
                        deviceOrientationEnabled = false;
                        updateGyroStatus(false);
                        console.warn('❌ Accès gyroscope refusé.');
                        alert('Accès au gyroscope refusé. Le contrôle de la vue VR ne fonctionnera pas.');
                    }
                })
                .catch(console.error);
        } else {
            // handle regular non-iOS 13+ devices
            window.addEventListener('deviceorientation', onDeviceOrientation, true);
            deviceOrientationEnabled = true;
            updateGyroStatus(true);
            console.log('✅ Accès gyroscope activé (mode non-iOS 13+).');
        }
    }

    function onDeviceOrientation(event) {
        if (!deviceOrientationEnabled) return;

        if (event.alpha === null || event.beta === null || event.gamma === null) {
            return;
        }

        const newAlpha = event.alpha || 0;
        const newBeta = event.beta || 0;
        const newGamma = event.gamma || 0;

        // Always update raw data for smoothing
        orientationData.alpha = newAlpha;
        orientationData.beta = newBeta;
        orientationData.gamma = newGamma;

        // Apply smoothing directly to the target values
        orientationData.smoothAlpha = lerp(orientationData.smoothAlpha, orientationData.alpha, SMOOTHING_FACTOR);
        orientationData.smoothBeta = lerp(orientationData.smoothBeta, orientationData.beta, SMOOTHING_FACTOR);
        orientationData.smoothGamma = lerp(orientationData.smoothGamma, orientationData.gamma, SMOOTHING_FACTOR);

        // Update camera only if significant movement or always if needed (simplified for this update)
        updateCameraFromOrientation();
    }

    function updateCameraFromOrientation() {
        if (!deviceOrientationEnabled) return;

        // Apply the calibration offsets
        let alpha = orientationData.smoothAlpha - orientationCalibration.alpha;
        let gamma = orientationData.smoothGamma - orientationCalibration.gamma; // Beta (pitch) is intentionally ignored for head tracking

        // Normalize angles
        alpha = normalizeAngle(alpha);
        // gamma = Math.max(-90, Math.min(90, gamma)); // Clamping gamma for roll, uncomment if needed for precise control

        // Convert to radians
        const alphaRad = THREE.MathUtils.degToRad(alpha);
        const gammaRad = THREE.MathUtils.degToRad(gamma);

        // Camera rotation order YXZ: Yaw (Y), Pitch (X), Roll (Z)
        camera.rotation.order = 'YXZ';

        // Yaw (left/right) - This should still work well
        camera.rotation.y = alphaRad;

        // Pitch (up/down) - DISABLED: No longer updated by gyroscope
        // camera.rotation.x = -betaRad; // This line is removed for this feature request

        // Roll (side-to-side tilt) - Keep it, but keep it minimal to avoid discomfort
        // You might want to adjust the multiplier or even set it to 0 if it's still weird.
        camera.rotation.z = -gammaRad * 0.2; // Keep a small, potentially negated roll
    }

    function calibrateOrientation() {
        // Set current smoothed orientation as the new calibration offset
        orientationCalibration.alpha = orientationData.smoothAlpha;
        orientationCalibration.beta = orientationData.smoothBeta; // Even if not used for pitch, good to reset
        orientationCalibration.gamma = orientationData.smoothGamma;
        console.log('✅ Calibré:', orientationCalibration);
        // Immediately apply the new calibration
        updateCameraFromOrientation();
        alert('Vue calibrée !');
    }

    function resetView() {
        // Reset camera rotation to its default forward state
        camera.rotation.set(0, 0, 0); // Reset all rotations
        camera.position.set(0, 1.6, 0); // Reset position as well, as movement is added

        // Re-calibrate to current device orientation if gyroscope is active
        if (deviceOrientationEnabled) {
            calibrateOrientation(); // This will make the current view "forward"
        }
        console.log('🔄 Vue recentrée.');
        alert('Vue recentrée !');
    }

    function lerp(a, b, t) {
        return a + (b - a) * t;
    }

    function normalizeAngle(angle) {
        // Ensure angle stays within -180 to 180 degrees or similar range for consistency
        angle = angle % 360;
        if (angle > 180) angle -= 360;
        if (angle < -180) angle += 360;
        return angle;
    }

    // Status updates for UI
    function updateVRStatus(status) {
        vrEnabled = status;
        document.getElementById('status-vr').textContent = status ? 'Activé' : 'Désactivé';
        document.getElementById('toggleVR').textContent = status ? 'Désactiver VR' : 'Activer VR';
    }

    function updateGyroStatus(status) {
        deviceOrientationEnabled = status;
        document.getElementById('status-gyro').textContent = status ? 'Disponible' : 'Non disponible';
    }

    function updateFullscreenStatus() {
        const fullscreenStatus = document.fullscreenElement !== null;
        document.getElementById('status-fullscreen').textContent = fullscreenStatus ? 'Activé' : 'Désactivé';
        document.getElementById('toggleFullscreen').textContent = fullscreenStatus ? 'Quitter Plein Écran' : 'Plein Écran';
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().then(() => {
                updateFullscreenStatus();
            }).catch(err => {
                console.error(`Erreur de plein écran: ${err.message}`);
            });
        } else {
            document.exitFullscreen().then(() => {
                updateFullscreenStatus();
            }).catch(err => {
                console.error(`Erreur de sortie de plein écran: ${err.message}`);
            });
        }
    }

    function toggleVR() {
        if (vrEnabled) {
            // Exit VR
            if (effect) {
                effect.dispose(); // Dispose the StereoEffect
                effect = null;
            }
            // Reset renderer to single view
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateVRStatus(false);
            console.log('Deactivated VR mode.');
            // Re-detect orientation as aspect ratio changes
            detectScreenOrientation();

        } else {
            // Enter VR
            // Check if device orientation is enabled, if not, prompt
            if (!deviceOrientationEnabled) {
                alert("Le gyroscope n'est pas activé. Le mode VR fonctionnera, mais le contrôle de la vue sera limité au mouvement (pas de suivi de la tête). Veuillez activer le gyroscope.");
                // You might want to call requestGyroPermission() here or guide the user.
            }

            if (!effect) {
                // Initialize StereoEffect outside init to allow toggling
                effect = new THREE.StereoEffect(renderer);
                effect.setSize(window.innerWidth, window.innerHeight);
                updateVRStatus(true);
                console.log('Activated VR mode.');
            }
            // Re-detect orientation as aspect ratio changes
            detectScreenOrientation();
            // Start rendering with effect
            // RequestAnimationFrame is already called in animate, just ensure effect.render is used.
            // No need for a separate animateEffect. Just animate will handle it.
        }
    }

    function detectScreenOrientation() {
        // Détecter l'orientation de l'écran
        if (window.innerHeight > window.innerWidth) {
            if (screenOrientation !== 'portrait') {
                screenOrientation = 'portrait';
                console.log('📱 Orientation: portrait');
                document.getElementById('orientation-warning').style.display = 'flex';
                document.getElementById('current-orientation').textContent = 'Portrait';
            }
        } else {
            if (screenOrientation !== 'landscape') {
                screenOrientation = 'landscape';
                console.log('📱 Orientation: paysage');
                document.getElementById('orientation-warning').style.display = 'none';
                document.getElementById('current-orientation').textContent = 'Paysage';
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (effect) { // Also resize StereoEffect if active
            effect.setSize(window.innerWidth, window.innerHeight);
        }
        console.log('📱 Redimensionnement:', window.innerWidth, 'x', window.innerHeight);

        // Détecter l'orientation
        detectScreenOrientation();
    }

    // Initialisation des statuts
    updateGyroStatus(false);
    updateVRStatus(false);
    updateFullscreenStatus();

    console.log('🎮 Application VR prête !');
</script>
</body>
</html>