<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Exp√©rience VR Mobile Am√©lior√©e</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn {
            padding: 12px 20px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
            transition: all 0.3s ease;
            min-width: 100px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-btn:hover, .control-btn:active {
            background: linear-gradient(45deg, #e55a2b, #e8851d);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        .control-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 24px;
            text-align: center;
            animation: pulse 2s infinite;
        }

        #gyro-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        #status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .status-item {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4757;
        }

        .status-dot.active {
            background: #2ed573;
            animation: blink 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (orientation: portrait) and (max-width: 768px) {
            #orientation-warning {
                display: flex;
            }
        }

        @media (orientation: landscape) {
            #orientation-warning {
                display: none;
            }
        }

        .vr-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 50;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .fullscreen-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Indicateur de mouvement */
        #movement-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 10;
            display: none; /* Masqu√© par d√©faut */
            transition: opacity 0.3s ease;
        }

        #score-display {
            position: absolute;
            top: 60px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
</head>
<body>
<div id="orientation-warning">
    <div style="font-size: 48px; margin-bottom: 20px;">üì±</div>
    <h2>Tournez votre t√©l√©phone</h2>
    <p>Basculez en mode paysage pour une exp√©rience VR optimale</p>
    <div style="margin-top: 20px; font-size: 16px; opacity: 0.8;">
        Meilleure exp√©rience avec un casque VR mobile
    </div>
</div>

<div id="gyro-permission">
    <div style="font-size: 48px; margin-bottom: 20px;">üß≠</div>
    <h2>Permission Gyroscope Requise</h2>
    <p>Autorisez l'acc√®s au gyroscope pour contr√¥ler la cam√©ra avec les mouvements de votre t√™te</p>
    <p style="font-size: 14px; opacity: 0.8; margin: 20px 0;">
        Cette permission est n√©cessaire pour une exp√©rience VR immersive
    </p>
    <button class="control-btn" onclick="requestGyroPermission()">Autoriser le Gyroscope</button>
    <button class="control-btn" onclick="skipGyroPermission()" style="margin-top: 10px; opacity: 0.7;">
        Continuer sans gyroscope
    </button>
</div>

<button class="fullscreen-btn" onclick="toggleFullscreen()" title="Plein √©cran">
    ‚õ∂
</button>

<div id="status-indicator">
    <div class="status-item">
        <div class="status-dot" id="gyro-status"></div>
        <span>Gyroscope</span>
    </div>
    <div class="status-item">
        <div class="status-dot" id="vr-status"></div>
        <span>Mode VR</span>
    </div>
    <div class="status-item">
        <div class="status-dot" id="fullscreen-status"></div>
        <span>Plein √©cran</span>
    </div>
</div>

<div id="score-display">
    <span>Score: <span id="score-value">0</span></span>
</div>

<div id="info">
    <h3>üöÄ VR Mobile - Exp√©rience Immersive</h3>
    <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
        <strong>Instructions:</strong>
        <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
            <li>Placez votre t√©l√©phone dans un casque VR</li>
            <li>Activez le mode VR pour l'√©cran divis√©</li>
            <li>Bougez la t√™te pour regarder autour</li>
            <li>En mode VR, touchez l'√©cran pour d√©marrer/arr√™ter le mouvement</li>
            <li>Tapez deux fois pour quitter le mode VR</li>
            <li>Collectez des objets pour augmenter votre vitesse et votre taille !</li>
        </ul>
    </div>
    <div style="font-size: 11px; opacity: 0.7;">
        Optimis√© pour iPhone et Android
    </div>
</div>

<div id="controls">
    <button id="vrToggle" class="control-btn">ü•Ω Mode VR</button>
    <button id="resetView" class="control-btn">üéØ Recentrer</button>
    <button id="calibrate" class="control-btn">‚öôÔ∏è Calibrer</button>
</div>

<div class="vr-overlay" id="vrOverlay">
    <h3>Mode VR Activ√©</h3>
    <p>Placez votre t√©l√©phone dans le casque VR</p>
    <p style="font-size: 14px; opacity: 0.8;">Tapez une fois pour d√©marrer/arr√™ter le mouvement</p>
    <p style="font-size: 14px; opacity: 0.8;">Tapez deux fois pour quitter le mode VR</p>
</div>

<div id="movement-indicator">
    <span>üö∂ Mouvement ON</span>
</div>

<div id="canvas-container"></div>

<script>
    // Configuration avanc√©e
    let scene, camera, renderer;
    let cubes = [], spheres = [], particles = [];
    let raycaster = new THREE.Raycaster();
    let clock = new THREE.Clock();

    // Variables VR et gyroscope am√©lior√©es
    let isVRMode = false;
    let deviceOrientationEnabled = false;
    let gyroPermissionGranted = false;
    let isFullscreen = false;
    let screenOrientation = 'portrait';

    // Syst√®me de calibrage am√©lior√©
    let orientationCalibration = {
        alpha: 0,
        beta: 0,
        gamma: 0,
        isCalibrated: false
    };

    // Contr√¥les gyroscope avec filtrage
    let orientationData = {
        alpha: 0,
        beta: 0,
        gamma: 0,
        smoothAlpha: 0,
        smoothBeta: 0,
        smoothGamma: 0
    };

    // Param√®tres de lissage pour les mouvements de la cam√©ra
    const SMOOTHING_FACTOR = 0.25; // Facteur de lissage pour le gyroscope
    const ORIENTATION_THRESHOLD = 0.05; // Seuil pour appliquer les mises √† jour d'orientation (r√©duit les mouvements brusques)

    // Variables de mouvement automatique en VR
    let isAutoMoving = false;
    let movementSpeed = 0.1; // Vitesse de d√©placement initiale
    const MOVEMENT_SPEED_INCREMENT = 0.02; // Augmentation de vitesse par objet collect√©

    // Variables pour l'effet du sol
    let floorMesh;
    let originalFloorColor;
    let lastCameraPosition = new THREE.Vector3();
    const STEP_DISTANCE_THRESHOLD = 1.0;
    const FLOOR_EFFECT_DURATION = 3000;

    // Player attributes
    let playerScore = 0;
    let playerHeight = 0.5; // Initial player height
    const PLAYER_HEIGHT_INCREMENT = 0.1; // How much player grows per collected item

    // Mat√©riaux et couleurs am√©lior√©s
    const colors = [
        0xff6b35, 0x4ecdc4, 0x45b7d1, 0x96ceb4,
        0xfeca57, 0xff9ff3, 0x54a0ff, 0x5f27cd,
        0x00d2d3, 0xff9f43, 0x10ac84, 0xee5a24
    ];

    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();

    init();
    animate();

    function init() {
        console.log('üöÄ Initialisation de l\'exp√©rience VR...');

        // Sc√®ne avec am√©liorations
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000015, 30, 150);

        // Cam√©ra optimis√©e pour VR mobile
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, playerHeight, 5); // Set initial camera height based on playerHeight
        lastCameraPosition.copy(camera.position);

        // Renderer avec optimisations
        renderer = new THREE.WebGLRenderer({
            antialias: window.devicePixelRatio < 2,
            powerPreference: "high-performance",
            alpha: false
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000015);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Configuration des contr√¥les
        setupControls();
        setupDeviceOrientation();
        setupFullscreenHandlers();

        // √âclairage am√©lior√©
        setupLighting();

        // Cr√©ation du monde
        createFloatingCubes();
        createFloatingSpheres();
        createParticleSystem();
        createEnvironment();

        // √âv√©nements
        setupEventListeners();

        // V√©rification des permissions
        checkGyroPermission();

        updateScoreDisplay(); // Initial display of score

        console.log('‚úÖ Initialisation termin√©e');
    }

    function setupControls() {
        const vrToggle = document.getElementById('vrToggle');
        const resetView = document.getElementById('resetView');
        const calibrate = document.getElementById('calibrate');

        vrToggle.addEventListener('click', toggleVRMode);
        resetView.addEventListener('click', resetCameraView);
        calibrate.addEventListener('click', calibrateOrientation);
    }

    function setupFullscreenHandlers() {
        document.addEventListener('fullscreenchange', updateFullscreenStatus);
        document.addEventListener('webkitfullscreenchange', updateFullscreenStatus);
        document.addEventListener('mozFullScreenChange', updateFullscreenStatus);
        document.addEventListener('MSFullscreenChange', updateFullscreenStatus);
    }

    function updateFullscreenStatus() {
        isFullscreen = !!(document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement);

        const status = document.getElementById('fullscreen-status');
        if (status) {
            status.className = isFullscreen ? 'status-dot active' : 'status-dot';
        }
    }

    function setupLighting() {
        // √âclairage ambiant
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        // Lumi√®re directionnelle avec ombres
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Lumi√®res color√©es anim√©es
        const light1 = new THREE.PointLight(0xff6b35, 1, 25);
        light1.position.set(-8, 6, -8);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x4ecdc4, 1, 25);
        light2.position.set(8, 6, 8);
        scene.add(light2);

        const light3 = new THREE.PointLight(0x45b7d1, 0.8, 20);
        light3.position.set(0, 8, -12);
        scene.add(light3);
    }

    function checkGyroPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('gyro-permission').style.display = 'flex';
        } else if (window.DeviceOrientationEvent) {
            // Android ou navigateurs qui ne n√©cessitent pas de permission explicite
            setupDeviceOrientation();
            document.getElementById('gyro-permission').style.display = 'none';
        } else {
            console.warn('‚ö†Ô∏è DeviceOrientation non support√©');
            updateGyroStatus(false);
        }
    }

    function requestGyroPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    console.log('üì± R√©ponse permission gyroscope:', response);
                    if (response === 'granted') {
                        gyroPermissionGranted = true;
                        document.getElementById('gyro-permission').style.display = 'none';
                        setupDeviceOrientation();
                        updateGyroStatus(true);
                    } else {
                        console.warn('‚ùå Permission gyroscope refus√©e');
                        updateGyroStatus(false);
                        document.getElementById('gyro-permission').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('‚ùå Erreur permission gyroscope:', error);
                    updateGyroStatus(false);
                    document.getElementById('gyro-permission').style.display = 'none';
                });
        } else {
            skipGyroPermission();
        }
    }

    function skipGyroPermission() {
        document.getElementById('gyro-permission').style.display = 'none';
        setupDeviceOrientation();
    }

    function setupDeviceOrientation() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', onDeviceOrientation, true);
            deviceOrientationEnabled = true;
            console.log('‚úÖ Gyroscope configur√©');
            updateGyroStatus(true);
        } else {
            console.warn('‚ö†Ô∏è DeviceOrientation non disponible');
            updateGyroStatus(false);
        }
    }

    function onDeviceOrientation(event) {
        if (!deviceOrientationEnabled) return;

        if (event.alpha === null || event.beta === null || event.gamma === null) {
            return;
        }

        const newAlpha = event.alpha || 0;
        const newBeta = event.beta || 0;
        const newGamma = event.gamma || 0;

        // Apply smoothing to raw sensor data
        orientationData.smoothAlpha = lerp(orientationData.smoothAlpha, newAlpha, SMOOTHING_FACTOR);
        orientationData.smoothBeta = lerp(orientationData.smoothBeta, newBeta, SMOOTHING_FACTOR);
        orientationData.smoothGamma = lerp(orientationData.smoothGamma, newGamma, SMOOTHING_FACTOR);

        // Calculate delta for alpha to handle 360 degree wrap-around
        if (lastAlpha !== null) {
            let deltaAlpha = orientationData.smoothAlpha - lastAlpha;

            // Handle alpha wrap-around (e.g., from 359 to 0, or 0 to 359)
            if (deltaAlpha > 180) {
                deltaAlpha -= 360;
            } else if (deltaAlpha < -180) {
                deltaAlpha += 360;
            }
            currentYaw += deltaAlpha;
        }
        lastAlpha = orientationData.smoothAlpha;

        updateCameraFromOrientation();
    }

    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function updateCameraFromOrientation() {
        if (!deviceOrientationEnabled) return;

        // Use currentYaw for Y-axis rotation (yaw)
        const yawRad = THREE.MathUtils.degToRad(currentYaw - orientationCalibration.alpha);

        // Use smoothed beta for X-axis rotation (pitch)
        const pitchRad = THREE.MathUtils.degToRad(orientationData.smoothBeta - orientationCalibration.beta);

        // Use smoothed gamma for Z-axis rotation (roll), with reduced effect
        const rollRad = -THREE.MathUtils.degToRad(orientationData.smoothGamma - orientationCalibration.gamma) * 0.2;

        camera.rotation.order = 'YXZ'; // Yaw (Y), Pitch (X), Roll (Z)
        camera.rotation.y = yawRad;
        camera.rotation.x = pitchRad;
        camera.rotation.z = rollRad;
    }
    function normalizeAngle(angle) {
        while (angle > 180) angle -= 360;
        while (angle < -180) angle += 360;
        return angle;
    }

    function calibrateOrientation() {
        if (!deviceOrientationEnabled) {
            alert('‚ö†Ô∏è Gyroscope non disponible pour la calibration');
            return;
        }

        orientationCalibration = {
            alpha: orientationData.smoothAlpha, // Calibrate alpha to current smoothAlpha
            beta: orientationData.smoothBeta,
            gamma: orientationData.smoothGamma,
            isCalibrated: true
        };
        currentYaw = 0; // Reset total yaw on calibration
        lastAlpha = orientationData.smoothAlpha; // Reset lastAlpha for delta calculation

        console.log('üéØ Orientation calibr√©e:', orientationCalibration);

        const btn = document.getElementById('calibrate');
        const originalText = btn.textContent;
        btn.textContent = '‚úÖ Calibr√©';
        btn.style.background = 'linear-gradient(45deg, #2ed573, #1e90ff)';

        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 2000);
    }

    function toggleVRMode() {
        const vrToggle = document.getElementById('vrToggle');
        const info = document.getElementById('info');
        const controls = document.getElementById('controls');
        const vrOverlay = document.getElementById('vrOverlay');
        const movementIndicator = document.getElementById('movement-indicator');

        isVRMode = !isVRMode;

        if (isVRMode) {
            console.log('ü•Ω Activation du mode VR');
            vrToggle.textContent = 'üëÅÔ∏è Mode Normal';
            vrToggle.classList.add('active');
            info.style.display = 'none';
            controls.style.display = 'none';
            vrOverlay.style.display = 'block';
            movementIndicator.style.display = 'block';

            if (!isFullscreen) {
                requestFullscreen();
            }

            setTimeout(() => {
                vrOverlay.style.display = 'none';
            }, 3000);

            isAutoMoving = true;
            updateMovementIndicator();
        } else {
            console.log('üëÅÔ∏è Retour au mode normal');
            vrToggle.textContent = 'ü•Ω Mode VR';
            vrToggle.classList.remove('active');
            info.style.display = 'block';
            controls.style.display = 'flex';
            vrOverlay.style.display = 'none';
            movementIndicator.style.display = 'none';

            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);

            isAutoMoving = false;
        }

        updateVRStatus(isVRMode);
    }

    function updateMovementIndicator() {
        const indicator = document.getElementById('movement-indicator');
        if (indicator) {
            if (isAutoMoving) {
                indicator.innerHTML = 'üö∂ Mouvement ON';
                indicator.style.opacity = 1;
            } else {
                indicator.innerHTML = 'üõë Mouvement OFF';
                indicator.style.opacity = 0.7;
            }
            indicator.style.display = 'block';
        }
    }

    function renderStereo() {
        if (!isVRMode) {
            renderer.render(scene, camera);
            return;
        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        const eyeSeparation = 0.032; // Standard eye separation

        renderer.setScissorTest(true);

        // Left eye
        renderer.setScissor(0, 0, width / 2, height);
        renderer.setViewport(0, 0, width / 2, height);
        camera.position.x -= eyeSeparation;
        renderer.render(scene, camera);

        // Right eye
        renderer.setScissor(width / 2, 0, width / 2, height);
        renderer.setViewport(width / 2, 0, width / 2, height);
        camera.position.x += eyeSeparation * 2;
        renderer.render(scene, camera);

        // Reset camera position for next frame
        camera.position.x -= eyeSeparation;
    }

    function resetCameraView() {
        console.log('üéØ Remise √† z√©ro de la vue');
        camera.position.set(0, playerHeight, 5); // Reset to current player height
        camera.rotation.set(0, 0, 0);
        calibrateOrientation();
    }
    let currentYaw = 0;
    let lastAlpha = null;

    function toggleFullscreen() {
        if (!isFullscreen) {
            requestFullscreen();
        } else {
            exitFullscreen();
        }
    }

    function requestFullscreen() {
        const element = document.documentElement;
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

        if (isIOS) {
            if (document.body.webkitRequestFullscreen) {
                document.body.webkitRequestFullscreen();
            } else if (document.body.webkitEnterFullscreen) {
                document.body.webkitEnterFullscreen();
            }

            if (window.screen && window.screen.orientation && window.screen.orientation.lock) {
                window.screen.orientation.lock('landscape').catch(e => {
                    console.warn('Impossible de verrouiller l\'orientation:', e);
                });
            }
        } else {
            const requestMethod = element.requestFullscreen ||
                element.webkitRequestFullscreen ||
                element.mozRequestFullScreen ||
                element.msRequestFullscreen;

            if (requestMethod) {
                requestMethod.call(element);
            }
        }
    }

    function exitFullscreen() {
        const exitMethod = document.exitFullscreen ||
            document.webkitExitFullscreen ||
            document.mozCancelFullScreen ||
            document.msExitFullscreen;

        if (exitMethod) {
            exitMethod.call(document);
        }
    }

    function updateGyroStatus(active) {
        const status = document.getElementById('gyro-status');
        if (status) {
            status.className = active ? 'status-dot active' : 'status-dot';
        }
    }

    function updateVRStatus(active) {
        const status = document.getElementById('vr-status');
        if (status) {
            status.className = active ? 'status-dot active' : 'status-dot';
        }
    }

    function updateScoreDisplay() {
        document.getElementById('score-value').textContent = playerScore;
    }

    function createFloatingCubes() {
        for (let i = 0; i < 20; i++) {
            const size = Math.random() * 1.5 + 1.0;
            const geometry = new THREE.BoxGeometry(size, size, size);

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });

            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;

            // Place objects at ground level (y slightly above 0)
            cube.position.set(
                (Math.random() - 0.5) * 40,
                size / 2, // Half of its size to sit on the floor
                (Math.random() - 0.5) * 40
            );

            cube.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            cube.userData = {
                originalColor: material.color.getHex(),
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                floatSpeed: Math.random() * 0.02 + 0.01,
                floatOffset: Math.random() * Math.PI * 2,
                originalPosition: cube.position.clone(),
                type: 'collectible', // Identify as collectible
                originalSize: size
            };

            cubes.push(cube);
            scene.add(cube);
        }
    }

    function createFloatingSpheres() {
        for (let i = 0; i < 15; i++) {
            const radius = Math.random() * 1.0 + 0.7; // Smaller spheres
            const geometry = new THREE.SphereGeometry(radius, 16, 16);

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.7,
                emissive: colors[Math.floor(Math.random() * colors.length)],
                emissiveIntensity: 0.2,
                shininess: 150
            });

            const sphere = new THREE.Mesh(geometry, material);
            sphere.castShadow = true;
            sphere.receiveShadow = true;

            // Place objects at ground level
            sphere.position.set(
                (Math.random() - 0.5) * 35,
                radius, // Half of its size (radius) to sit on the floor
                (Math.random() - 0.5) * 35
            );

            sphere.userData = {
                originalColor: material.color.getHex(),
                originalEmissive: material.emissive.getHex(),
                floatSpeed: Math.random() * 0.03 + 0.01,
                floatOffset: Math.random() * Math.PI * 2,
                pulseSpeed: Math.random() * 0.05 + 0.02,
                originalPosition: sphere.position.clone(),
                type: 'collectible', // Identify as collectible
                originalRadius: radius
            };

            spheres.push(sphere);
            scene.add(sphere);
        }
    }

    function createParticleSystem() {
        const particleCount = 300;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            positions[i3] = (Math.random() - 0.5) * 120;
            positions[i3 + 1] = Math.random() * 60;
            positions[i3 + 2] = (Math.random() - 0.5) * 120;

            const color = new THREE.Color(0xffffff); // White particles
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 1.5,
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        particles.push(particleSystem);
    }

    function createEnvironment() {
        // Sol avec grille am√©lior√©e
        const gridGeometry = new THREE.PlaneGeometry(120, 120, 60, 60);
        const gridMaterial = new THREE.MeshPhongMaterial({
            color: 0x333366,
            wireframe: true,
            transparent: true,
            opacity: 0.2,
            emissive: 0x000000,
            emissiveIntensity: 0
        });

        floorMesh = new THREE.Mesh(gridGeometry, gridMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = 0;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);
        originalFloorColor = new THREE.Color(0x333366);

        // Ciel √©toil√© am√©lior√©
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(1500 * 3);
        const starColors = new Float32Array(1500 * 3);

        for (let i = 0; i < 1500; i++) {
            const i3 = i * 3;

            starPositions[i3] = (Math.random() - 0.5) * 300;
            starPositions[i3 + 1] = Math.random() * 150 + 20;
            starPositions[i3 + 2] = (Math.random() - 0.5) * 300;

            const intensity = Math.random();
            starColors[i3] = intensity;
            starColors[i3 + 1] = intensity;
            starColors[i3 + 2] = intensity;
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));

        const starsMaterial = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 0.9,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
    }

    function setupEventListeners() {
        window.addEventListener('resize', onWindowResize);

        let lastTapTime = 0;
        window.addEventListener('touchend', (event) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTapTime;

            if (isVRMode) {
                if (tapLength < 500 && tapLength > 0) {
                    // Double tap to exit VR mode
                    toggleVRMode();
                } else {
                    // Single tap to toggle auto movement
                    isAutoMoving = !isAutoMoving;
                    updateMovementIndicator();
                }
            } else {
                // If not in VR mode, allow object interaction (e.g., for testing on desktop)
                if (event.changedTouches && event.changedTouches.length === 1) {
                    const touch = event.changedTouches[0];
                    checkIntersection(touch.clientX, touch.clientY);
                } else if (!event.touches) { // For mouse clicks on desktop
                    checkIntersection(event.clientX, event.clientY);
                }
            }
            lastTapTime = currentTime;
        });

        window.addEventListener('click', (event) => {
            if (!isVRMode) { // Only allow click interaction outside VR mode
                checkIntersection(event.clientX, event.clientY);
            }
        });

        window.addEventListener('orientationchange', () => {
            console.log('üì± Changement d\'orientation');
            setTimeout(detectScreenOrientation, 300);
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('‚è∏Ô∏è Application en arri√®re-plan');
            } else {
                console.log('‚ñ∂Ô∏è Application au premier plan');
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);

        frameCount++;
        const currentTime = performance.now();
        if (currentTime - lastTime >= 1000) {
            console.log(`üìä FPS: ${frameCount}`);
            frameCount = 0;
            lastTime = currentTime;
        }

        if (isVRMode && isAutoMoving) {
            moveCameraForward();
        }

        // Check for collisions with collectibles
        checkCollisions();

        render();
    }

    function moveCameraForward() {
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0; // Keep movement on the horizontal plane
        direction.normalize();

        camera.position.addScaledVector(direction, movementSpeed);

        // Ensure camera stays at the current playerHeight
        camera.position.y = playerHeight;

        // Check for "step" to trigger floor effect
        if (camera.position.distanceTo(lastCameraPosition) > STEP_DISTANCE_THRESHOLD) {
            triggerFloorEffect(camera.position.clone());
            lastCameraPosition.copy(camera.position);
        }
    }

    function triggerFloorEffect(position) {
        if (!floorMesh) return;

        const originalEmissive = floorMesh.material.emissive.clone();
        const originalEmissiveIntensity = floorMesh.material.emissiveIntensity;

        const flashColor = new THREE.Color(0x88CCFF);
        const flashIntensity = 2.0;

        const startTime = Date.now();

        function animateFloorEffect() {
            const elapsedTime = Date.now() - startTime;
            const progress = elapsedTime / FLOOR_EFFECT_DURATION;

            if (progress < 1) {
                floorMesh.material.emissive.lerpColors(flashColor, originalEmissive, progress);
                floorMesh.material.emissiveIntensity = lerp(flashIntensity, originalEmissiveIntensity, progress);

                if (progress > 0.5 && Math.random() < 0.2) {
                    createRisingParticles(position);
                }

                requestAnimationFrame(animateFloorEffect);
            } else {
                floorMesh.material.emissive.copy(originalEmissive);
                floorMesh.material.emissiveIntensity = originalEmissiveIntensity;
            }
        }
        animateFloorEffect();
    }

    function createRisingParticles(originPosition) {
        const particleCount = 15;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colorsArray = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const lifetimes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            positions[i3] = originPosition.x + (Math.random() - 0.5) * 0.5;
            positions[i3 + 1] = 0.1;
            positions[i3 + 2] = originPosition.z + (Math.random() - 0.5) * 0.5;

            const intensity = Math.random();
            colorsArray[i3] = intensity;
            colorsArray[i3 + 1] = intensity;
            colorsArray[i3 + 2] = intensity;

            velocities[i3] = (Math.random() - 0.5) * 0.01;
            velocities[i3 + 1] = Math.random() * 0.05 + 0.01;
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;

            lifetimes[i] = Math.random() * 1.5 + 0.5;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
        geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));

        const material = new THREE.PointsMaterial({
            size: 1.0,
            transparent: true,
            opacity: 1.0,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const risingParticles = new THREE.Points(geometry, material);
        scene.add(risingParticles);

        const effectStartTime = clock.getElapsedTime();

        function animateRisingParticles() {
            const currentTime = clock.getElapsedTime();
            const positions = risingParticles.geometry.attributes.position.array;
            const velocities = risingParticles.geometry.attributes.velocity.array;
            const lifetimes = risingParticles.geometry.attributes.lifetime.array;

            let particlesAlive = 0;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const particleLifetime = lifetimes[i];
                const age = currentTime - effectStartTime;

                if (age < particleLifetime) {
                    positions[i3] += velocities[i3];
                    positions[i3 + 1] += velocities[i3 + 1];
                    positions[i3 + 2] += velocities[i3 + 2];

                    const fadeProgress = age / particleLifetime;
                    risingParticles.material.opacity = 1.0 - fadeProgress;
                    particlesAlive++;
                } else {
                    positions[i3] = positions[i3 + 1] = positions[i3 + 2] = 10000;
                }
            }

            risingParticles.geometry.attributes.position.needsUpdate = true;

            if (particlesAlive > 0) {
                requestAnimationFrame(animateRisingParticles);
            } else {
                scene.remove(risingParticles);
                geometry.dispose();
                material.dispose();
            }
        }
        animateRisingParticles();
    }


    function render() {
        const time = clock.getElapsedTime();

        cubes.forEach((cube) => {
            const userData = cube.userData;
            cube.rotation.x += userData.rotationSpeed.x;
            cube.rotation.y += userData.rotationSpeed.y;
            cube.rotation.z += userData.rotationSpeed.z;
            // Cubes are fixed at ground level, no floating
        });

        spheres.forEach((sphere) => {
            const userData = sphere.userData;
            const scale = 1 + Math.sin(time * userData.pulseSpeed) * 0.15;
            sphere.scale.setScalar(scale);
            const emissiveIntensity = 0.1 + Math.sin(time * userData.pulseSpeed * 2) * 0.1;
            sphere.material.emissiveIntensity = emissiveIntensity;
            // Spheres are fixed at ground level, no floating
        });

        particles.forEach(particleSystem => {
            particleSystem.rotation.y += 0.0005;
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(time * 0.001 + positions[i] * 0.01) * 0.02;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        });

        renderStereo();
    }

    // Modified checkIntersection to handle clicks/taps for desktop, but not used in VR
    function checkIntersection(clientX, clientY) {
        const mouse = new THREE.Vector2();
        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const collectibles = [...cubes, ...spheres];
        const intersects = raycaster.intersectObjects(collectibles);

        if (intersects.length > 0) {
            const object = intersects[0].object;
            if (object.userData.type === 'collectible') {
                collectObject(object);
            }
        }
    }
    const playerSphereGeo = new THREE.SphereGeometry(playerHeight * 0.3, 16, 16);
    const playerSphereMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
    const playerSphereMesh = new THREE.Mesh(playerSphereGeo, playerSphereMat);
    scene.add(playerSphereMesh);

    function checkCollisions() {
        // Only check collisions if auto-moving in VR mode
        if (!isVRMode || !isAutoMoving) return;

        const playerBoundingSphere = new THREE.Sphere(camera.position, playerHeight * 0.3); // Adjust multiplier as needed

        const allCollectibles = [...cubes, ...spheres];

        for (let i = 0; i < allCollectibles.length; i++) {
            const object = allCollectibles[i];
            if (object.userData.type === 'collectible') {
                const objectBoundingSphere = new THREE.Sphere();
                new THREE.Box3().setFromObject(object).getBoundingSphere(objectBoundingSphere);

                // Reduce object bounding sphere radius slightly for easier collection
                objectBoundingSphere.radius *= 0.8;

                if (playerBoundingSphere.intersectsSphere(objectBoundingSphere)) {
                    collectObject(object);
                    break; // Only collect one object per frame to avoid issues
                }
            }
        }
    }

    function collectObject(object) {
        // Play a collection sound or visual effect
        createSelectionEffect(object.position);

        // Remove object from scene and its respective array
        scene.remove(object);
        if (object.geometry.type === 'BoxGeometry') {
            cubes = cubes.filter(c => c !== object);
        } else if (object.geometry.type === 'SphereGeometry') {
            spheres = spheres.filter(s => s !== object);
        }

        // Increase score
        playerScore += 1;
        updateScoreDisplay();

        // Increase speed
        movementSpeed += MOVEMENT_SPEED_INCREMENT;
        console.log('Current speed:', movementSpeed);

        // Increase player height
        playerHeight += PLAYER_HEIGHT_INCREMENT;
        camera.position.y = playerHeight;
        console.log('Current height:', playerHeight);

        const originalSizeOrRadius = object.geometry.type === 'BoxGeometry' ? object.userData.originalSize : object.userData.originalRadius;

        // Remove object from scene and its respective array
        scene.remove(object);
        if (object.geometry.type === 'BoxGeometry') {
            cubes = cubes.filter(c => c !== object);
        } else if (object.geometry.type === 'SphereGeometry') {
            spheres = spheres.filter(s => s !== object);
        }

        // ... (existing code)

        // Respawn object after a short delay, passing the original size/radius
        setTimeout(() => {
            respawnObject(object.geometry.type, originalSizeOrRadius);
        }, 1000); // Respawn after 1 second

    }

    function respawnObject(type, originalSizeOrRadius) { // Pass original size/radius as an argument
        let newObject;
        if (type === 'BoxGeometry') {
            const size = originalSizeOrRadius; // Use the original size
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            newObject = new THREE.Mesh(geometry, material);
            newObject.castShadow = true; // Ensure shadow casting is re-enabled
            newObject.receiveShadow = true; // Ensure shadow receiving is re-enabled
            newObject.position.y = size / 2;
            newObject.userData = {
                originalColor: material.color.getHex(),
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                floatSpeed: Math.random() * 0.02 + 0.01,
                floatOffset: Math.random() * Math.PI * 2,
                originalPosition: newObject.position.clone(),
                type: 'collectible',
                originalSize: size // Store the original size
            };
            cubes.push(newObject);
        } else if (type === 'SphereGeometry') {
            const radius = originalSizeOrRadius; // Use the original radius
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.7,
                emissive: colors[Math.floor(Math.random() * colors.length)],
                emissiveIntensity: 0.2,
                shininess: 150
            });
            newObject = new THREE.Mesh(geometry, material);
            newObject.castShadow = true; // Ensure shadow casting is re-enabled
            newObject.receiveShadow = true; // Ensure shadow receiving is re-enabled
            newObject.position.y = radius;
            newObject.userData = {
                originalColor: material.color.getHex(),
                originalEmissive: material.emissive.getHex(),
                floatSpeed: Math.random() * 0.03 + 0.01,
                floatOffset: Math.random() * Math.PI * 2,
                pulseSpeed: Math.random() * 0.05 + 0.02,
                originalPosition: newObject.position.clone(),
                type: 'collectible',
                originalRadius: radius // Store the original radius
            };
            spheres.push(newObject);
        }

        if (newObject) {
            // Respawn at a new random location within the environment boundaries
            newObject.position.set(
                (Math.random() - 0.5) * 40,
                newObject.position.y, // Maintain its original height based on its type
                (Math.random() - 0.5) * 40
            );
            newObject.userData.originalPosition.copy(newObject.position); // Update original position for floating/pulsing effects if applicable
            scene.add(newObject);
            console.log('Object respawned:', newObject.uuid);
        }
    }

    function createSelectionEffect(position) {
        const particleCount = 20;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = position.x + (Math.random() - 0.5) * 2;
            positions[i + 1] = position.y + (Math.random() - 0.5) * 2;
            positions[i + 2] = position.z + (Math.random() - 0.5) * 2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 3,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending
        });

        const effect = new THREE.Points(geometry, material);
        scene.add(effect);

        const startTime = performance.now();
        const duration = 1000;

        function animateEffect() {
            const elapsed = performance.now() - startTime;
            const progress = elapsed / duration;

            if (progress < 1) {
                material.opacity = 1 - progress;
                effect.scale.setScalar(1 + progress * 2);
                requestAnimationFrame(animateEffect);
            } else {
                scene.remove(effect);
                geometry.dispose();
                material.dispose();
            }
        }

        animateEffect();
    }

    function detectScreenOrientation() {
        if (window.innerHeight > window.innerWidth) {
            if (screenOrientation !== 'portrait') {
                screenOrientation = 'portrait';
                console.log('üì± Orientation: portrait');
                document.getElementById('orientation-warning').style.display = 'flex';
            }
        } else {
            if (screenOrientation !== 'landscape') {
                screenOrientation = 'landscape';
                console.log('üì± Orientation: paysage');
                document.getElementById('orientation-warning').style.display = 'none';
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        console.log('üì± Redimensionnement:', window.innerWidth, 'x', window.innerHeight);

        detectScreenOrientation();
    }

    updateGyroStatus(false);
    updateVRStatus(false);
    updateFullscreenStatus();

    console.log('üéÆ Application VR pr√™te !');
</script>
</body>
</html>