<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Exp√©rience VR Mobile Am√©lior√©e</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn {
            padding: 12px 20px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
            transition: all 0.3s ease;
            min-width: 100px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-btn:hover, .control-btn:active {
            background: linear-gradient(45deg, #e55a2b, #e8851d);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        .control-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 24px;
            text-align: center;
            animation: pulse 2s infinite;
        }

        #gyro-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        #status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .status-item {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4757;
        }

        .status-dot.active {
            background: #2ed573;
            animation: blink 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (orientation: portrait) and (max-width: 768px) {
            #orientation-warning {
                display: flex;
            }
        }

        @media (orientation: landscape) {
            #orientation-warning {
                display: none;
            }
        }

        .vr-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 50;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .fullscreen-btn:hover {
            background: rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
<div id="orientation-warning">
    <div style="font-size: 48px; margin-bottom: 20px;">üì±</div>
    <h2>Tournez votre t√©l√©phone</h2>
    <p>Basculez en mode paysage pour une exp√©rience VR optimale</p>
    <div style="margin-top: 20px; font-size: 16px; opacity: 0.8;">
        Meilleure exp√©rience avec un casque VR mobile
    </div>
</div>

<div id="gyro-permission">
    <div style="font-size: 48px; margin-bottom: 20px;">üß≠</div>
    <h2>Permission Gyroscope Requise</h2>
    <p>Autorisez l'acc√®s au gyroscope pour contr√¥ler la cam√©ra avec les mouvements de votre t√™te</p>
    <p style="font-size: 14px; opacity: 0.8; margin: 20px 0;">
        Cette permission est n√©cessaire pour une exp√©rience VR immersive
    </p>
    <button class="control-btn" onclick="requestGyroPermission()">Autoriser le Gyroscope</button>
    <button class="control-btn" onclick="skipGyroPermission()" style="margin-top: 10px; opacity: 0.7;">
        Continuer sans gyroscope
    </button>
</div>

<button class="fullscreen-btn" onclick="toggleFullscreen()" title="Plein √©cran">
    ‚õ∂
</button>

<div id="status-indicator">
    <div class="status-item">
        <div class="status-dot" id="gyro-status"></div>
        <span>Gyroscope</span>
    </div>
    <div class="status-item">
        <div class="status-dot" id="vr-status"></div>
        <span>Mode VR</span>
    </div>
    <div class="status-item">
        <div class="status-dot" id="fullscreen-status"></div>
        <span>Plein √©cran</span>
    </div>
</div>

<div id="info">
    <h3>üöÄ VR Mobile - Exp√©rience Immersive</h3>
    <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
        <strong>Instructions:</strong>
        <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
            <li>Placez votre t√©l√©phone dans un casque VR</li>
            <li>Activez le mode VR pour l'√©cran divis√©</li>
            <li>Bougez la t√™te pour regarder autour</li>
            <li>Tapez pour interagir avec les objets</li>
        </ul>
    </div>
    <div style="font-size: 11px; opacity: 0.7;">
        Optimis√© pour iPhone et Android
    </div>
</div>

<div id="controls">
    <button id="vrToggle" class="control-btn">ü•Ω Mode VR</button>
    <button id="resetView" class="control-btn">üéØ Recentrer</button>
    <button id="calibrate" class="control-btn">‚öôÔ∏è Calibrer</button>
</div>

<div class="vr-overlay" id="vrOverlay">
    <h3>Mode VR Activ√©</h3>
    <p>Placez votre t√©l√©phone dans le casque VR</p>
    <p style="font-size: 14px; opacity: 0.8;">Tapez deux fois pour quitter</p>
</div>

<div id="canvas-container"></div>

<script>
    // Configuration avanc√©e
    let scene, camera, renderer;
    let cubes = [], spheres = [], particles = [];
    let raycaster = new THREE.Raycaster();
    let clock = new THREE.Clock();
    let mouse = new THREE.Vector2();

    // Variables VR et gyroscope am√©lior√©es
    let isVRMode = false;
    let deviceOrientationEnabled = false;
    let gyroPermissionGranted = false;
    let isFullscreen = false;
    let screenOrientation = 'portrait';

    // Syst√®me de calibrage am√©lior√©
    let orientationCalibration = {
        alpha: 0,
        beta: 0,
        gamma: 0,
        isCalibrated: false
    };

    // Contr√¥les gyroscope avec filtrage
    let orientationData = {
        alpha: 0,
        beta: 0,
        gamma: 0,
        smoothAlpha: 0,
        smoothBeta: 0,
        smoothGamma: 0
    };

    // Param√®tres de lissage
    const SMOOTHING_FACTOR = 0.15;
    const ORIENTATION_THRESHOLD = 0.5;

    // Mat√©riaux et couleurs am√©lior√©s
    const colors = [
        0xff6b35, 0x4ecdc4, 0x45b7d1, 0x96ceb4,
        0xfeca57, 0xff9ff3, 0x54a0ff, 0x5f27cd,
        0x00d2d3, 0xff9f43, 0x10ac84, 0xee5a24
    ];

    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();

    init();
    animate();

    function init() {
        console.log('üöÄ Initialisation de l\'exp√©rience VR...');

        // Sc√®ne avec am√©liorations
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000015, 30, 150);

        // Cam√©ra optimis√©e pour VR mobile
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);

        // Renderer avec optimisations
        renderer = new THREE.WebGLRenderer({
            antialias: window.devicePixelRatio < 2,
            powerPreference: "high-performance",
            alpha: false
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000015);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Configuration des contr√¥les
        setupControls();
        setupDeviceOrientation();
        setupFullscreenHandlers();

        // √âclairage am√©lior√©
        setupLighting();

        // Cr√©ation du monde
        createFloatingCubes();
        createFloatingSpheres();
        createParticleSystem();
        createEnvironment();

        // √âv√©nements
        setupEventListeners();

        // V√©rification des permissions
        checkGyroPermission();

        console.log('‚úÖ Initialisation termin√©e');
    }

    function setupControls() {
        const vrToggle = document.getElementById('vrToggle');
        const resetView = document.getElementById('resetView');
        const calibrate = document.getElementById('calibrate');

        vrToggle.addEventListener('click', toggleVRMode);
        resetView.addEventListener('click', resetCameraView);
        calibrate.addEventListener('click', calibrateOrientation);
    }

    function setupFullscreenHandlers() {
        document.addEventListener('fullscreenchange', updateFullscreenStatus);
        document.addEventListener('webkitfullscreenchange', updateFullscreenStatus);
        document.addEventListener('mozfullscreenchange', updateFullscreenStatus);
        document.addEventListener('MSFullscreenChange', updateFullscreenStatus);
    }

    function updateFullscreenStatus() {
        isFullscreen = !!(document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement);

        const status = document.getElementById('fullscreen-status');
        if (status) {
            status.className = isFullscreen ? 'status-dot active' : 'status-dot';
        }
    }

    function setupLighting() {
        // √âclairage ambiant
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        // Lumi√®re directionnelle avec ombres
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Lumi√®res color√©es anim√©es
        const light1 = new THREE.PointLight(0xff6b35, 1, 25);
        light1.position.set(-8, 6, -8);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x4ecdc4, 1, 25);
        light2.position.set(8, 6, 8);
        scene.add(light2);

        const light3 = new THREE.PointLight(0x45b7d1, 0.8, 20);
        light3.position.set(0, 8, -12);
        scene.add(light3);
    }

    function checkGyroPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('gyro-permission').style.display = 'flex';
        } else if (window.DeviceOrientationEvent) {
            // Android ou navigateurs qui ne n√©cessitent pas de permission explicite
            setupDeviceOrientation();
            document.getElementById('gyro-permission').style.display = 'none';
        } else {
            console.warn('‚ö†Ô∏è DeviceOrientation non support√©');
            updateGyroStatus(false);
        }
    }

    function requestGyroPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    console.log('üì± R√©ponse permission gyroscope:', response);
                    if (response === 'granted') {
                        gyroPermissionGranted = true;
                        document.getElementById('gyro-permission').style.display = 'none';
                        setupDeviceOrientation();
                        updateGyroStatus(true);
                    } else {
                        console.warn('‚ùå Permission gyroscope refus√©e');
                        updateGyroStatus(false);
                        document.getElementById('gyro-permission').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('‚ùå Erreur permission gyroscope:', error);
                    updateGyroStatus(false);
                    document.getElementById('gyro-permission').style.display = 'none';
                });
        } else {
            skipGyroPermission();
        }
    }

    function skipGyroPermission() {
        document.getElementById('gyro-permission').style.display = 'none';
        setupDeviceOrientation();
    }

    function setupDeviceOrientation() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', onDeviceOrientation, true);
            deviceOrientationEnabled = true;
            console.log('‚úÖ Gyroscope configur√©');
            updateGyroStatus(true);
        } else {
            console.warn('‚ö†Ô∏è DeviceOrientation non disponible');
            updateGyroStatus(false);
        }
    }

    function onDeviceOrientation(event) {
        if (!deviceOrientationEnabled) return;

        // V√©rifier la validit√© des donn√©es
        if (event.alpha === null || event.beta === null || event.gamma === null) {
            return;
        }

        // Mise √† jour des donn√©es brutes
        const newAlpha = event.alpha || 0;
        const newBeta = event.beta || 0;
        const newGamma = event.gamma || 0;
        
        // Filtrer les petits mouvements pour √©viter les saccades
        if (Math.abs(newAlpha - orientationData.alpha) > ORIENTATION_THRESHOLD ||
            Math.abs(newBeta - orientationData.beta) > ORIENTATION_THRESHOLD ||
            Math.abs(newGamma - orientationData.gamma) > ORIENTATION_THRESHOLD) {
            
            orientationData.alpha = newAlpha;
            orientationData.beta = newBeta;
            orientationData.gamma = newGamma;

            // Lissage des donn√©es avec facteur adaptatif bas√© sur la vitesse de mouvement
            const movementMagnitude = Math.abs(newAlpha - orientationData.smoothAlpha) + 
                                     Math.abs(newBeta - orientationData.smoothBeta) + 
                                     Math.abs(newGamma - orientationData.smoothGamma);
            
            // Ajuster le facteur de lissage en fonction de la magnitude du mouvement
            // Mouvements rapides = moins de lissage, mouvements lents = plus de lissage
            const adaptiveFactor = Math.min(0.8, Math.max(0.1, SMOOTHING_FACTOR * (1 + movementMagnitude * 0.01)));
            
            orientationData.smoothAlpha = lerp(orientationData.smoothAlpha, orientationData.alpha, adaptiveFactor);
            orientationData.smoothBeta = lerp(orientationData.smoothBeta, orientationData.beta, adaptiveFactor);
            orientationData.smoothGamma = lerp(orientationData.smoothGamma, orientationData.gamma, adaptiveFactor);

            updateCameraFromOrientation();
        }
    }

    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function updateCameraFromOrientation() {
        if (!deviceOrientationEnabled) return;

        // Apply calibration
        let alpha = orientationData.smoothAlpha - orientationCalibration.alpha;
        let beta = orientationData.smoothBeta - orientationCalibration.beta;
        let gamma = orientationData.smoothGamma - orientationCalibration.gamma;

        // Normalize angles (keep existing function)
        alpha = normalizeAngle(alpha);
        // Beta should be clamped to -90 to 90 degrees for pitch
        beta = Math.max(-90, Math.min(90, beta));
        // Gamma should be clamped too, for roll
        gamma = Math.max(-90, Math.min(90, gamma));

        // Convert angles to radians
        const alphaRad = THREE.MathUtils.degToRad(alpha);
        const betaRad = THREE.MathUtils.degToRad(beta);
        const gammaRad = THREE.MathUtils.degToRad(gamma);

        // Create a quaternion from device orientation angles.
        // The order of application is critical. 'ZXY' is often recommended for device orientation.
        // It's alpha (z-axis), beta (x-axis), gamma (y-axis) as per W3C specification.
        // However, Three.js Euler order is typically YXZ for camera.
        // Let's use a temporary quaternion to build the rotation carefully.
        const quaternion = new THREE.Quaternion();
        const euler = new THREE.Euler();

        // The DeviceOrientationEvent alpha, beta, gamma values
        // are often applied in Z-X-Y order (heading, pitch, roll)
        // Adjust for device specific rotations and coordinate systems.
        // The key is to find the right mapping for your device.

        // Common approach for Android and iOS (adjusting for landscape/portrait)
        // and transforming to Three.js Y-up, Z-forward system.
        // This often involves a reorientation to a "neutral" landscape mode
        // before applying the final rotation.

        // Initial rotation based on device orientation (alpha, beta, gamma)
        // This is a common pattern that attempts to map device orientation to a view quaternion.
        // `beta` controls pitch (up/down), `gamma` controls roll (side-to-side tilt),
        // `alpha` controls yaw (left/right turn).

        // It is often necessary to apply an initial orientation correction.
        // For instance, if you are holding your phone in landscape mode with the home button to the right,
        // this typically means gamma will be positive for "right-side up" phone.
        // Here, we try to align `beta` with pitch and `alpha` with yaw directly.

        // Construct a quaternion from the alpha, beta, gamma Euler angles.
        // This uses the "device" coordinate system.
        // We'll create a local Euler and then convert to quaternion.
        euler.set(betaRad, alphaRad, -gammaRad, 'YXZ'); // YXZ order: yaw, pitch, roll. Gamma negated for common usage.

        quaternion.setFromEuler(euler);

        // Further corrections might be needed based on the device's native orientation
        // and how you hold it in the VR headset.
        // If your phone is typically held in landscape-left for VR (home button right),
        // you might need an additional rotation.

        // Example for typical landscape orientation in VR (home button to the right usually)
        // This effectively rotates the entire orientation space by 90 degrees around Z axis.
        const screenTransform = new THREE.Quaternion();
        const screenOrientationAngle = window.screen.orientation ? window.screen.orientation.angle : 0;

        // This compensation varies by device and how it defines its "neutral" orientation.
        // For many Android devices and browsers, if held landscape with home button right,
        // a `window.screen.orientation.angle` of 90 degrees might be present.
        // You would need to rotate the device's reported orientation to align with your camera's expectations.
        // A common pattern is:
        //  * Rotate around X by 90 degrees (from portrait to landscape 'natural' position)
        //  * Then apply device-specific rotation based on screen.orientation.angle

        // Let's simplify first, and if issues persist, we can add screen.orientation compensation.
        // The current 'YXZ' order and negated gamma is a good starting point.

        // Apply the rotation to the camera's quaternion directly
        camera.quaternion.copy(quaternion);

        // If your camera is still looking in the wrong direction (e.g., 90 degrees off on initial load),
        // you might need a static offset quaternion.
        // For example, to make it look "forward" instead of "up":
        // let initialCorrection = new THREE.Quaternion();
        // initialCorrection.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2); // Rotate 90 degrees around X to point forward
        // camera.quaternion.multiplyQuaternions(initialCorrection, quaternion);

        // This is crucial: the calibration needs to be applied correctly.
        // When you calibrate, you are setting the "zero" point of the head tracking.
        // The rotation should be relative to this calibrated zero.
        // Let's ensure `calibrateOrientation` sets `orientationCalibration` correctly and
        // `updateCameraFromOrientation` applies it as a delta.

        // A better way to apply calibration:
        // Store the initial quaternion when calibrating.
        // Then, in `updateCameraFromOrientation`, get the current device quaternion,
        // and apply the inverse of the calibration quaternion to it.

        // If we want a simple relative rotation:
        // 1. Get initial orientation (calibration)
        // 2. Get current orientation
        // 3. Calculate difference between current and initial.
        // 4. Apply difference to camera.

        // Let's refine the calibration logic and how it's used.
        // Instead of `orientationCalibration.alpha`, etc., store a `calibratedQuaternion`.
        // And when updating, compute `currentQuaternion * inverse(calibratedQuaternion)`.

        // For now, let's stick to your current angle-based calibration, but emphasize the angle normalization.
        // The `normalizeAngle` function helps keep angles within a reasonable range.

        // Re-check signs for alpha, beta, gamma based on *your device's behavior*.
        // - `alpha` (yaw): Typically `-alphaRad` for Three.js `rotation.y` to turn left for positive alpha.
        // - `beta` (pitch): Typically `-betaRad` for Three.js `rotation.x` to look down for positive beta.
        // - `gamma` (roll): Can be `gammaRad` or `-gammaRad`. `0.5` factor reduces intensity.

        // Based on typical device orientation behavior and Three.js camera:
        camera.rotation.order = 'YXZ'; // Yaw (Y), Pitch (X), Roll (Z) - common for camera
        camera.rotation.y = alphaRad;   // Alpha usually controls yaw (left/right)
        camera.rotation.x = betaRad;    // Beta usually controls pitch (up/down)
        camera.rotation.z = -gammaRad;  // Gamma usually controls roll (tilt left/right). Negated for common convention.
                                        // You might want to apply the 0.5 factor back to gamma if too strong.
    }
    
    function normalizeAngle(angle) {
        while (angle > 180) angle -= 360;
        while (angle < -180) angle += 360;
        return angle;
    }

    function calibrateOrientation() {
        if (!deviceOrientationEnabled) {
            alert('‚ö†Ô∏è Gyroscope non disponible pour la calibration');
            return;
        }

        orientationCalibration = {
            alpha: orientationData.alpha,
            beta: orientationData.beta,
            gamma: orientationData.gamma,
            isCalibrated: true
        };

        console.log('üéØ Orientation calibr√©e:', orientationCalibration);

        // Feedback visuel
        const btn = document.getElementById('calibrate');
        const originalText = btn.textContent;
        btn.textContent = '‚úÖ Calibr√©';
        btn.style.background = 'linear-gradient(45deg, #2ed573, #1e90ff)';

        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 2000);
    }

    function toggleVRMode() {
        const vrToggle = document.getElementById('vrToggle');
        const info = document.getElementById('info');
        const controls = document.getElementById('controls');
        const vrOverlay = document.getElementById('vrOverlay');

        isVRMode = !isVRMode;

        if (isVRMode) {
            console.log('ü•Ω Activation du mode VR');
            vrToggle.textContent = 'üëÅÔ∏è Mode Normal';
            vrToggle.classList.add('active');
            info.style.display = 'none';
            controls.style.display = 'none';
            vrOverlay.style.display = 'block';

            // Forcer le plein √©cran en mode VR
            if (!isFullscreen) {
                requestFullscreen();
            }

            // Masquer l'overlay apr√®s 3 secondes
            setTimeout(() => {
                vrOverlay.style.display = 'none';
            }, 3000);

        } else {
            console.log('üëÅÔ∏è Retour au mode normal');
            vrToggle.textContent = 'ü•Ω Mode VR';
            vrToggle.classList.remove('active');
            info.style.display = 'block';
            controls.style.display = 'flex';
            vrOverlay.style.display = 'none';

            // Restaurer le rendu normal
            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
        }

        updateVRStatus(isVRMode);
    }

    function renderStereo() {
        if (!isVRMode) {
            renderer.render(scene, camera);
            return;
        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        const eyeSeparation = 0.032; // Distance inter-pupillaire

        renderer.setScissorTest(true);

        // ≈íil gauche
        renderer.setScissor(0, 0, width / 2, height);
        renderer.setViewport(0, 0, width / 2, height);
        camera.position.x -= eyeSeparation;
        renderer.render(scene, camera);

        // ≈íil droit
        renderer.setScissor(width / 2, 0, width / 2, height);
        renderer.setViewport(width / 2, 0, width / 2, height);
        camera.position.x += eyeSeparation * 2;
        renderer.render(scene, camera);

        // Restaurer la position
        camera.position.x -= eyeSeparation;
    }

    function resetCameraView() {
        console.log('üéØ Remise √† z√©ro de la vue');
        camera.position.set(0, 1.6, 5);
        camera.rotation.set(0, 0, 0);
        calibrateOrientation();
    }

    function toggleFullscreen() {
        if (!isFullscreen) {
            requestFullscreen();
        } else {
            exitFullscreen();
        }
    }

    function requestFullscreen() {
        const element = document.documentElement;
        
        // V√©rifier si c'est un iPhone
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        if (isIOS) {
            // Sur iOS, utiliser une approche diff√©rente pour le plein √©cran
            if (document.body.webkitRequestFullscreen) {
                document.body.webkitRequestFullscreen();
            } else if (document.body.webkitEnterFullscreen) {
                document.body.webkitEnterFullscreen();
            }
            
            // Forcer l'orientation paysage sur iOS
            if (window.screen && window.screen.orientation && window.screen.orientation.lock) {
                window.screen.orientation.lock('landscape').catch(e => {
                    console.warn('Impossible de verrouiller l\'orientation:', e);
                });
            }
        } else {
            // M√©thode standard pour les autres appareils
            const requestMethod = element.requestFullscreen ||
                element.webkitRequestFullscreen ||
                element.mozRequestFullScreen ||
                element.msRequestFullscreen;

            if (requestMethod) {
                requestMethod.call(element);
            }
        }
    }

    function exitFullscreen() {
        const exitMethod = document.exitFullscreen ||
            document.webkitExitFullscreen ||
            document.mozCancelFullScreen ||
            document.msExitFullscreen;

        if (exitMethod) {
            exitMethod.call(document);
        }
    }

    function updateGyroStatus(active) {
        const status = document.getElementById('gyro-status');
        if (status) {
            status.className = active ? 'status-dot active' : 'status-dot';
        }
    }

    function updateVRStatus(active) {
        const status = document.getElementById('vr-status');
        if (status) {
            status.className = active ? 'status-dot active' : 'status-dot';
        }
    }

    function createFloatingCubes() {
        for (let i = 0; i < 20; i++) {
            const size = Math.random() * 1.5 + 0.5;
            const geometry = new THREE.BoxGeometry(size, size, size);

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });

            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;

            cube.position.set(
                (Math.random() - 0.5) * 40,
                Math.random() * 15 + 2,
                (Math.random() - 0.5) * 40
            );

            cube.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            cube.userData = {
                originalColor: material.color.getHex(),
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                floatSpeed: Math.random() * 0.02 + 0.01,
                floatOffset: Math.random() * Math.PI * 2,
                originalPosition: cube.position.clone()
            };

            cubes.push(cube);
            scene.add(cube);
        }
    }

    function createFloatingSpheres() {
        for (let i = 0; i < 15; i++) {
            const radius = Math.random() * 1.2 + 0.3;
            const geometry = new THREE.SphereGeometry(radius, 16, 16);

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.7,
                emissive: colors[Math.floor(Math.random() * colors.length)],
                emissiveIntensity: 0.2,
                shininess: 150
            });

            const sphere = new THREE.Mesh(geometry, material);
            sphere.castShadow = true;
            sphere.receiveShadow = true;

            sphere.position.set(
                (Math.random() - 0.5) * 35,
                Math.random() * 12 + 3,
                (Math.random() - 0.5) * 35
            );

            sphere.userData = {
                originalColor: material.color.getHex(),
                originalEmissive: material.emissive.getHex(),
                floatSpeed: Math.random() * 0.03 + 0.01,
                floatOffset: Math.random() * Math.PI * 2,
                pulseSpeed: Math.random() * 0.05 + 0.02,
                originalPosition: sphere.position.clone()
            };

            spheres.push(sphere);
            scene.add(sphere);
        }
    }

    function createParticleSystem() {
        const particleCount = 300;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            positions[i3] = (Math.random() - 0.5) * 120;
            positions[i3 + 1] = Math.random() * 60;
            positions[i3 + 2] = (Math.random() - 0.5) * 120;

            const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 1.5,
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        particles.push(particleSystem);
    }

    function createEnvironment() {
        // Sol avec grille am√©lior√©e
        const gridGeometry = new THREE.PlaneGeometry(120, 120, 60, 60);
        const gridMaterial = new THREE.MeshBasicMaterial({
            color: 0x333366,
            wireframe: true,
            transparent: true,
            opacity: 0.2
        });

        const grid = new THREE.Mesh(gridGeometry, gridMaterial);
        grid.rotation.x = -Math.PI / 2;
        grid.position.y = 0;
        grid.receiveShadow = true;
        scene.add(grid);

        // Ciel √©toil√© am√©lior√©
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(1500 * 3);
        const starColors = new Float32Array(1500 * 3);

        for (let i = 0; i < 1500; i++) {
            const i3 = i * 3;

            starPositions[i3] = (Math.random() - 0.5) * 300;
            starPositions[i3 + 1] = Math.random() * 150 + 20;
            starPositions[i3 + 2] = (Math.random() - 0.5) * 300;

            const intensity = Math.random();
            starColors[i3] = intensity;
            starColors[i3 + 1] = intensity;
            starColors[i3 + 2] = intensity;
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));

        const starsMaterial = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 0.9,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
    }

    function setupEventListeners() {
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('click', onMouseClick);
        window.addEventListener('touchstart', onTouchStart);
        window.addEventListener('orientationchange', () => {
            console.log('üì± Changement d\'orientation');
            setTimeout(detectScreenOrientation, 300); // D√©lai pour laisser le temps au navigateur de s'ajuster
        });

        // Double tap pour quitter le mode VR
        let lastTouchTime = 0;
        window.addEventListener('touchend', (event) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTouchTime;
            if (tapLength < 500 && tapLength > 0 && isVRMode) {
                toggleVRMode();
            }
            lastTouchTime = currentTime;
        });

        // Gestion de la visibilit√© de la page
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('‚è∏Ô∏è Application en arri√®re-plan');
            } else {
                console.log('‚ñ∂Ô∏è Application au premier plan');
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);

        // Monitoring des performances
        frameCount++;
        const currentTime = performance.now();
        if (currentTime - lastTime >= 1000) {
            console.log(`üìä FPS: ${frameCount}`);
            frameCount = 0;
            lastTime = currentTime;
        }

        render();
    }

    function render() {
        const time = clock.getElapsedTime();

        // Animation des cubes avec optimisations
        cubes.forEach((cube) => {
            const userData = cube.userData;

            cube.rotation.x += userData.rotationSpeed.x;
            cube.rotation.y += userData.rotationSpeed.y;
            cube.rotation.z += userData.rotationSpeed.z;

            const floatY = Math.sin(time * userData.floatSpeed + userData.floatOffset) * 2;
            cube.position.y = userData.originalPosition.y + floatY;
        });

        // Animation des sph√®res
        spheres.forEach((sphere) => {
            const userData = sphere.userData;

            const floatY = Math.sin(time * userData.floatSpeed + userData.floatOffset) * 2.5;
            const floatX = Math.cos(time * userData.floatSpeed * 0.5) * 0.5;

            sphere.position.y = userData.originalPosition.y + floatY;
            sphere.position.x = userData.originalPosition.x + floatX;

            const scale = 1 + Math.sin(time * userData.pulseSpeed) * 0.15;
            sphere.scale.setScalar(scale);

            // Animation de l'√©mission
            const emissiveIntensity = 0.1 + Math.sin(time * userData.pulseSpeed * 2) * 0.1;
            sphere.material.emissiveIntensity = emissiveIntensity;
        });

        // Animation des particules
        particles.forEach(particleSystem => {
            particleSystem.rotation.y += 0.0005;
            const positions = particleSystem.geometry.attributes.position.array;

            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(time * 0.001 + positions[i] * 0.01) * 0.02;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
        });

        // Rendu st√©r√©oscopique ou normal
        renderStereo();
    }

    function onMouseClick(event) {
        if (isVRMode) return;

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        checkIntersection();
    }

    function onTouchStart(event) {
        event.preventDefault();
        if (event.touches.length === 1) {
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            checkIntersection();
        }
    }

    function checkIntersection() {
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects([...cubes, ...spheres]);

        if (intersects.length > 0) {
            const object = intersects[0].object;

            // Animation de s√©lection am√©lior√©e
            const originalColor = object.userData.originalColor;

            object.material.color.setHex(0xffffff);
            object.scale.setScalar(1.5);

            // Effet de particules
            createSelectionEffect(object.position);

            setTimeout(() => {
                object.material.color.setHex(originalColor);
                object.scale.setScalar(1);
            }, 800);
        }
    }

    function createSelectionEffect(position) {
        const particleCount = 20;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = position.x + (Math.random() - 0.5) * 2;
            positions[i + 1] = position.y + (Math.random() - 0.5) * 2;
            positions[i + 2] = position.z + (Math.random() - 0.5) * 2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 3,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending
        });

        const effect = new THREE.Points(geometry, material);
        scene.add(effect);

        // Animation de disparition
        const startTime = performance.now();
        const duration = 1000;

        function animateEffect() {
            const elapsed = performance.now() - startTime;
            const progress = elapsed / duration;

            if (progress < 1) {
                material.opacity = 1 - progress;
                effect.scale.setScalar(1 + progress * 2);
                requestAnimationFrame(animateEffect);
            } else {
                scene.remove(effect);
                geometry.dispose();
                material.dispose();
            }
        }

        animateEffect();
    }

    function detectScreenOrientation() {
        // D√©tecter l'orientation de l'√©cran
        if (window.innerHeight > window.innerWidth) {
            if (screenOrientation !== 'portrait') {
                screenOrientation = 'portrait';
                console.log('üì± Orientation: portrait');
                document.getElementById('orientation-warning').style.display = 'flex';
            }
        } else {
            if (screenOrientation !== 'landscape') {
                screenOrientation = 'landscape';
                console.log('üì± Orientation: paysage');
                document.getElementById('orientation-warning').style.display = 'none';
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        console.log('üì± Redimensionnement:', window.innerWidth, 'x', window.innerHeight);
        
        // D√©tecter l'orientation
        detectScreenOrientation();
    }

    // Initialisation des statuts
    updateGyroStatus(false);
    updateVRStatus(false);
    updateFullscreenStatus();

    console.log('üéÆ Application VR pr√™te !');
</script>
</body>
</html>