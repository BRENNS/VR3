<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Expérience VR Mobile Améliorée</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: background 0.3s ease;
        }

        .control-button:active {
            background: rgba(255, 255, 255, 0.4);
        }

        #status-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 15px;
        }

        .status-item {
            display: flex;
            align-items: center;
        }

        .status-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #888;
            transition: background-color 0.3s ease;
        }

        .status-circle.active {
            background-color: #4CAF50; /* Green */
        }

        .status-circle.error {
            background-color: #f44336; /* Red */
        }

        #orientation-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 165, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 18px;
            text-align: center;
            z-index: 200;
            display: none; /* Hidden by default */
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* Reticle for Gaze-Based Movement */
        #reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px; /* Adjust size as needed */
            height: 20px; /* Adjust size as needed */
            border-radius: 50%;
            border: 2px solid white;
            box-sizing: border-box;
            z-index: 1000; /* Ensure it's on top */
            opacity: 0.8;
            pointer-events: none; /* Make sure it doesn't block clicks */
            transition: border-color 0.1s ease-in-out, transform 0.1s ease-in-out, opacity 0.1s ease-in-out;
        }

        #reticle.active-gaze {
            border-color: limegreen;
            transform: translate(-50%, -50%) scale(0.8);
            opacity: 1;
        }

        #reticle.gazing-ready {
            border-color: yellow;
            transform: translate(-50%, -50%) scale(1.1);
        }

    </style>
</head>
<body>
<div id="info">
    <h3>Expérience VR Mobile</h3>
    <p>Utilisez les capteurs de votre appareil pour explorer.</p>
    <div id="status-container">
        <div class="status-item"><span id="gyro-status" class="status-circle"></span> Gyroscope</div>
        <div class="status-item"><span id="vr-status" class="status-circle"></span> Mode VR</div>
        <div class="status-item"><span id="fullscreen-status" class="status-circle"></span> Plein Écran</div>
    </div>
</div>

<div id="controls">
    <button id="request-gyro-permission" class="control-button" style="display: none;">Activer Gyroscope</button>
    <button id="toggle-vr" class="control-button">Activer VR</button>
    <button id="calibrate-orientation" class="control-button">Calibrer Vue</button>
    <button id="toggle-fullscreen" class="control-button">Plein Écran</button>
</div>

<div id="orientation-warning">
    <p>Veuillez faire pivoter votre appareil en mode **paysage** pour une expérience VR optimale.</p>
</div>

<div id="reticle"></div> <script>
    // --- THREE.js Variables ---
    let scene, camera, renderer, effect;
    let container;
    let playerGroup; // A group to hold the camera for movement
    let stars;
    let vrEnabled = false;
    let deviceOrientationEnabled = false;
    let fullscreenEnabled = false;
    let screenOrientation = 'portrait'; // Initial assumption

    // --- Device Orientation Variables ---
    let orientationData = { alpha: 0, beta: 0, gamma: 0, smoothAlpha: 0, smoothBeta: 0, smoothGamma: 0 };
    let orientationCalibration = { alpha: 0, beta: 0, gamma: 0 }; // Stores initial orientation for calibration

    // --- Smoothing Parameters ---
    const SMOOTHING_FACTOR = 0.25; // Adjusted for smoother movement
    const ORIENTATION_THRESHOLD = 0.2; // Threshold for updating camera (reduces tiny jitters)

    // --- Gaze-Based Movement Variables ---
    let raycaster;
    let movementTarget; // The invisible object to look at for movement
    let movementSpeed = 0.05; // Speed of movement
    let gazeTimer = 0;
    const GAZE_ACTIVATION_TIME = 1000; // Time in ms to look at target to start moving
    let isMoving = false;
    let reticle; // The DOM element for the reticle

    // --- Initial Setup ---
    init();
    animate();

    function init() {
        // Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510); // Darker background

        // Camera setup
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        // Player group for movement
        playerGroup = new THREE.Group();
        scene.add(playerGroup);
        playerGroup.add(camera); // Camera is now a child of playerGroup

        // Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Effect for VR stereo rendering
        effect = new THREE.StereoEffect(renderer);
        effect.setSize(window.innerWidth, window.innerHeight);

        // Add Reticle
        reticle = document.getElementById('reticle');

        // Raycaster for gaze detection
        raycaster = new THREE.Raycaster();

        // Add a movement target in front of the player (invisible)
        const movementTargetGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const movementTargetMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0 }); // Invisible
        movementTarget = new THREE.Mesh(movementTargetGeometry, movementTargetMaterial);
        movementTarget.position.set(0, 0, -5); // Position it 5 units in front of the camera (relative to playerGroup)
        playerGroup.add(movementTarget); // Add target to player group so it moves with the player

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        // --- Objects in the Scene ---
        addStars();
        addCube(); // Add a simple cube to see movement

        // --- Event Listeners ---
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('deviceorientation', onDeviceOrientation, true);

        // Button Listeners
        document.getElementById('request-gyro-permission').addEventListener('click', requestDeviceOrientationPermission);
        document.getElementById('toggle-vr').addEventListener('click', toggleVR);
        document.getElementById('calibrate-orientation').addEventListener('click', calibrateOrientation);
        document.getElementById('toggle-fullscreen').addEventListener('click', toggleFullscreen);

        // Initial checks
        detectScreenOrientation();
        checkDeviceOrientationSupport();

        // Initial calibration
        calibrateOrientation(); // Calibrate on start
    }

    function addStars() {
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });

        const vertices = [];
        for (let i = 0; i < 5000; i++) {
            const x = THREE.MathUtils.randFloatSpread(2000); // spread over 2000 units
            const y = THREE.MathUtils.randFloatSpread(2000);
            const z = THREE.MathUtils.randFloatSpread(2000);
            vertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
    }

    function addCube() {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshNormalMaterial(); // Shows normals
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 0, -10); // Place it in front of the camera
        scene.add(cube);
    }

    function animate() {
        requestAnimationFrame(animate);

        // Update gaze timer and handle movement
        if (vrEnabled && deviceOrientationEnabled) {
            checkGazeForMovement();
            if (isMoving) {
                movePlayerForward();
            }
        }

        // Render based on VR mode
        if (vrEnabled) {
            effect.render(scene, camera);
        } else {
            renderer.render(scene, camera);
        }
    }

    // --- Device Orientation and Camera Control ---

    function normalizeAngle(angle) {
        // Normalize angle to be between -180 and 180 (or 0 and 360)
        // This function attempts to keep angles within a continuous range.
        // For calibration, ensure it returns a consistent range.
        return angle % 360;
    }

    function lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
    }

    function onDeviceOrientation(event) {
        if (!deviceOrientationEnabled) return;

        // Check if event has valid data
        if (event.alpha === null || event.beta === null || event.gamma === null) {
            console.warn("DeviceOrientationEvent received null values.");
            return;
        }

        const newAlpha = event.alpha;
        const newBeta = event.beta;
        const newGamma = event.gamma;

        // Apply smoothing to all axes
        orientationData.smoothAlpha = lerp(orientationData.smoothAlpha, newAlpha, SMOOTHING_FACTOR);
        orientationData.smoothBeta = lerp(orientationData.smoothBeta, newBeta, SMOOTHING_FACTOR);
        orientationData.smoothGamma = lerp(orientationData.smoothGamma, newGamma, SMOOTHING_FACTOR);

        // We will *always* call updateCameraFromOrientation to ensure the camera
        // rotation (yaw) is updated, but movement is conditional on gaze.
        updateCameraFromOrientation();
    }

    function updateCameraFromOrientation() {
        if (!deviceOrientationEnabled) return;

        // Apply calibration offsets
        let alpha = orientationData.smoothAlpha - orientationCalibration.alpha;
        let beta = orientationData.smoothBeta - orientationCalibration.beta;
        let gamma = orientationData.smoothGamma - orientationCalibration.gamma;

        // Normalize angles
        alpha = normalizeAngle(alpha);
        beta = Math.max(-90, Math.min(90, beta)); // Clamp beta
        gamma = Math.max(-90, Math.min(90, gamma)); // Clamp gamma

        // Convert to radians
        const alphaRad = THREE.MathUtils.degToRad(alpha);
        // const betaRad = THREE.MathUtils.degToRad(beta); // No longer used for pitch
        const gammaRad = THREE.MathUtils.degToRad(gamma);

        // Set camera rotation order
        camera.rotation.order = 'YXZ';

        // --- Only apply YAW (left/right) ---
        camera.rotation.y = alphaRad;

        // --- DISABLE PITCH (up/down) ---
        camera.rotation.x = 0; // Explicitly set pitch to zero

        // --- Minimize/Disable ROLL (side-to-side tilt) ---
        // Roll can still be disorienting. Setting it to 0 or a very small value.
        camera.rotation.z = -gammaRad * 0.05; // Greatly reduced roll, potentially negated. Set to 0 for no roll.
    }

    function calibrateOrientation() {
        if (deviceOrientationEnabled) {
            // Store current smoothed orientation as the calibration point
            orientationCalibration.alpha = orientationData.smoothAlpha;
            orientationCalibration.beta = orientationData.smoothBeta;
            orientationCalibration.gamma = orientationData.smoothGamma;
            console.log('🔄 Calibrage effectué:', orientationCalibration);
        } else {
            console.warn('Gyroscope non activé pour calibrer.');
        }
    }

    // --- Gaze-Based Movement Functions ---

    function checkGazeForMovement() {
        // Set raycaster origin to camera position and direction to camera's forward
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); // Vector2(0,0) is the center of the screen

        // Intersect with the movementTarget
        const intersects = raycaster.intersectObjects([movementTarget], false);

        if (intersects.length > 0) {
            // Gaze is on target
            reticle.classList.add('gazing-ready');
            gazeTimer += (1000 / 60); // Assuming ~60 FPS, add time in ms
            if (gazeTimer >= GAZE_ACTIVATION_TIME) {
                reticle.classList.add('active-gaze');
                isMoving = true;
            }
        } else {
            // Gaze is off target
            reticle.classList.remove('gazing-ready');
            reticle.classList.remove('active-gaze');
            gazeTimer = 0;
            isMoving = false;
        }
    }

    function movePlayerForward() {
        // Move the playerGroup forward relative to its current rotation
        // The camera is a child, so it will move with the playerGroup.
        const forwardVector = new THREE.Vector3(0, 0, -1); // Forward is -Z in Three.js default
        forwardVector.applyQuaternion(playerGroup.quaternion); // Apply playerGroup's rotation to get global forward
        playerGroup.position.addScaledVector(forwardVector, movementSpeed);
    }

    // --- UI and Fullscreen Controls ---

    function requestDeviceOrientationPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        deviceOrientationEnabled = true;
                        updateGyroStatus(true);
                        console.log('✅ Gyroscope : Autorisation accordée.');
                    } else {
                        deviceOrientationEnabled = false;
                        updateGyroStatus(false);
                        console.warn('❌ Gyroscope : Autorisation refusée.');
                    }
                    document.getElementById('request-gyro-permission').style.display = 'none'; // Hide button after request
                })
                .catch(error => {
                    console.error('Erreur lors de la demande d\'autorisation du gyroscope:', error);
                    updateGyroStatus(false);
                });
        } else {
            // For non-iOS 13+ devices, deviceorientation event is usually available by default
            deviceOrientationEnabled = true;
            updateGyroStatus(true);
            console.log('✅ Gyroscope : Disponible par défaut.');
            document.getElementById('request-gyro-permission').style.display = 'none'; // Hide button
        }
    }

    function checkDeviceOrientationSupport() {
        if (window.DeviceOrientationEvent) {
            // Check if requestPermission is needed (iOS 13+)
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                document.getElementById('request-gyro-permission').style.display = 'block';
                deviceOrientationEnabled = false; // Will be set to true on permission granted
            } else {
                // Not iOS 13+, so events should fire directly
                deviceOrientationEnabled = true;
                updateGyroStatus(true);
            }
        } else {
            console.warn('❌ DeviceOrientationEvent non supporté sur cet appareil/navigateur.');
            updateGyroStatus(false, true); // Mark as error
            document.getElementById('request-gyro-permission').style.display = 'none';
        }
    }

    function updateGyroStatus(status, error = false) {
        const gyroStatusCircle = document.getElementById('gyro-status');
        gyroStatusCircle.classList.remove('active', 'error');
        if (status) {
            gyroStatusCircle.classList.add('active');
        } else if (error) {
            gyroStatusCircle.classList.add('error');
        }
    }

    function toggleVR() {
        vrEnabled = !vrEnabled;
        updateVRStatus(vrEnabled);
        onWindowResize(); // Re-render in case of VR mode change

        // Reset camera position when toggling VR
        // This ensures the player starts from a known point in VR mode
        playerGroup.position.set(0, 0, 0);
        camera.rotation.set(0, 0, 0); // Reset camera rotation
        calibrateOrientation(); // Recalibrate for the new VR mode view
        console.log('⚡ Mode VR:', vrEnabled ? 'Activé' : 'Désactivé');
    }

    function updateVRStatus(status) {
        const vrStatusCircle = document.getElementById('vr-status');
        vrStatusCircle.classList.remove('active');
        if (status) {
            vrStatusCircle.classList.add('active');
        }
        document.getElementById('toggle-vr').textContent = status ? 'Désactiver VR' : 'Activer VR';
    }

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().then(() => {
                fullscreenEnabled = true;
                updateFullscreenStatus();
                console.log('Full screen activé.');
            }).catch(err => {
                console.error(`Erreur plein écran: ${err.message} (${err.name})`);
            });
        } else {
            document.exitFullscreen().then(() => {
                fullscreenEnabled = false;
                updateFullscreenStatus();
                console.log('Full screen désactivé.');
            });
        }
    }

    function updateFullscreenStatus() {
        fullscreenEnabled = document.fullscreenElement !== null;
        const fullscreenStatusCircle = document.getElementById('fullscreen-status');
        fullscreenStatusCircle.classList.remove('active');
        if (fullscreenEnabled) {
            fullscreenStatusCircle.classList.add('active');
        }
        document.getElementById('toggle-fullscreen').textContent = fullscreenEnabled ? 'Quitter Plein Écran' : 'Plein Écran';
    }

    function animateEffect() {
        if (vrEnabled) {
            effect.render(scene, camera);
            requestAnimationFrame(animateEffect);
        } else {
            // Only render once if VR is disabled, then stop the loop for effect
            // scene.remove(effect); // Effect is not added to scene, it uses the renderer
            // geometry.dispose(); // These are from a previous context, not directly used here
            // material.dispose(); // Same here
        }
    }

    function detectScreenOrientation() {
        // Détecter l'orientation de l'écran
        if (window.innerHeight > window.innerWidth) {
            if (screenOrientation !== 'portrait') {
                screenOrientation = 'portrait';
                console.log('📱 Orientation: portrait');
                document.getElementById('orientation-warning').style.display = 'flex';
            }
        } else {
            if (screenOrientation !== 'landscape') {
                screenOrientation = 'landscape';
                console.log('📱 Orientation: paysage');
                document.getElementById('orientation-warning').style.display = 'none';
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        if (vrEnabled) {
            effect.setSize(window.innerWidth, window.innerHeight);
        } else {
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        console.log('📱 Redimensionnement:', window.innerWidth, 'x', window.innerHeight);

        // Détecter l'orientation
        detectScreenOrientation();
    }

    // Initialisation des statuts
    updateGyroStatus(false);
    updateVRStatus(false);
    updateFullscreenStatus();

    console.log('🎮 Application VR prête !');
</script>
</body>
</html>