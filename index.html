<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Exp√©rience VR Mobile Am√©lior√©e</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn {
            padding: 12px 20px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
            transition: all 0.3s ease;
            min-width: 100px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-btn:hover, .control-btn:active {
            background: linear-gradient(45deg, #e55a2b, #e8851d);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        .control-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 24px;
            text-align: center;
            animation: pulse 2s infinite;
        }

        #gyro-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        #status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .status-item {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4757;
        }

        .status-dot.active {
            background: #2ed573;
            animation: blink 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (orientation: portrait) and (max-width: 768px) {
            #orientation-warning {
                display: flex;
            }
        }

        @media (orientation: landscape) {
            #orientation-warning {
                display: none;
            }
        }

        .vr-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 50;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .fullscreen-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Indicateur de mouvement */
        #movement-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 10;
            display: none; /* Masqu√© par d√©faut */
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body>
<div id="orientation-warning">
    <div style="font-size: 48px; margin-bottom: 20px;">üì±</div>
    <h2>Tournez votre t√©l√©phone</h2>
    <p>Basculez en mode paysage pour une exp√©rience VR optimale</p>
    <div style="margin-top: 20px; font-size: 16px; opacity: 0.8;">
        Meilleure exp√©rience avec un casque VR mobile
    </div>
</div>

<div id="gyro-permission">
    <div style="font-size: 48px; margin-bottom: 20px;">üß≠</div>
    <h2>Permission Gyroscope Requise</h2>
    <p>Autorisez l'acc√®s au gyroscope pour contr√¥ler la cam√©ra avec les mouvements de votre t√™te</p>
    <p style="font-size: 14px; opacity: 0.8; margin: 20px 0;">
        Cette permission est n√©cessaire pour une exp√©rience VR immersive
    </p>
    <button class="control-btn" onclick="requestGyroPermission()">Autoriser le Gyroscope</button>
    <button class="control-btn" onclick="skipGyroPermission()" style="margin-top: 10px; opacity: 0.7;">
        Continuer sans gyroscope
    </button>
</div>

<button class="fullscreen-btn" onclick="toggleFullscreen()" title="Plein √©cran">
    ‚õ∂
</button>

<div id="status-indicator">
    <div class="status-item">
        <div class="status-dot" id="gyro-status"></div>
        <span>Gyroscope</span>
    </div>
    <div class="status-item">
        <div class="status-dot" id="vr-status"></div>
        <span>Mode VR</span>
    </div>
    <div class="status-item">
        <div class="status-dot" id="fullscreen-status"></div>
        <span>Plein √©cran</span>
    </div>
</div>

<div id="info">
    <h3>üöÄ VR Mobile - Exp√©rience Immersive</h3>
    <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
        <strong>Instructions:</strong>
        <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
            <li>Placez votre t√©l√©phone dans un casque VR</li>
            <li>Activez le mode VR pour l'√©cran divis√©</li>
            <li>Bougez la t√™te pour regarder autour</li>
            <li>En mode VR, touchez l'√©cran pour d√©marrer/arr√™ter le mouvement</li>
            <li>Tapez deux fois pour quitter le mode VR</li>
        </ul>
    </div>
    <div style="font-size: 11px; opacity: 0.7;">
        Optimis√© pour iPhone et Android
    </div>
</div>

<div id="controls">
    <button id="vrToggle" class="control-btn">ü•Ω Mode VR</button>
    <button id="resetView" class="control-btn">üéØ Recentrer</button>
    <button id="calibrate" class="control-btn">‚öôÔ∏è Calibrer</button>
</div>

<div class="vr-overlay" id="vrOverlay">
    <h3>Mode VR Activ√©</h3>
    <p>Placez votre t√©l√©phone dans le casque VR</p>
    <p style="font-size: 14px; opacity: 0.8;">Tapez une fois pour d√©marrer/arr√™ter le mouvement</p>
    <p style="font-size: 14px; opacity: 0.8;">Tapez deux fois pour quitter le mode VR</p>
</div>

<div id="movement-indicator">
    <span>üö∂ Mouvement ON</span>
</div>

<div id="canvas-container"></div>

<script>
    // Configuration avanc√©e
    let scene, camera, renderer;
    let cubes = [], spheres = [], particles = [];
    let raycaster = new THREE.Raycaster();
    let clock = new THREE.Clock();
    let mouse = new THREE.Vector2();

    // Variables VR et gyroscope am√©lior√©es
    let isVRMode = false;
    let deviceOrientationEnabled = false;
    let gyroPermissionGranted = false;
    let isFullscreen = false;
    let screenOrientation = 'portrait';

    // Syst√®me de calibrage am√©lior√©
    let orientationCalibration = {
        alpha: 0,
        beta: 0,
        gamma: 0,
        isCalibrated: false
    };

    // Contr√¥les gyroscope avec filtrage
    let orientationData = {
        alpha: 0,
        beta: 0,
        gamma: 0,
        smoothAlpha: 0,
        smoothBeta: 0,
        smoothGamma: 0
    };

    // Param√®tres de lissage
    const SMOOTHING_FACTOR = 0.25;
    const ORIENTATION_THRESHOLD = 0.2;

    // Variables de mouvement automatique en VR
    let isAutoMoving = false; // Nouvelle variable pour le mouvement automatique
    const MOVEMENT_SPEED = 0.1; // Vitesse de d√©placement

    // Variables pour l'effet du sol
    let floorMesh;
    let originalFloorColor;
    let lastCameraPosition = new THREE.Vector3();
    const STEP_DISTANCE_THRESHOLD = 1.0; // Distance pour d√©clencher l'effet de pas
    const FLOOR_EFFECT_DURATION = 3000; // Dur√©e de l'effet lumineux en millisecondes

    // Mat√©riaux et couleurs am√©lior√©s
    const colors = [
        0xff6b35, 0x4ecdc4, 0x45b7d1, 0x96ceb4,
        0xfeca57, 0xff9ff3, 0x54a0ff, 0x5f27cd,
        0x00d2d3, 0xff9f43, 0x10ac84, 0xee5a24
    ];

    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();

    // Collision variables
    const PLAYER_RADIUS = 0.5; // Approximate radius of the player/camera
    const OBJECT_PUSH_FORCE = 0.2; // How much objects are pushed
    const OBJECT_DAMPING = 0.9; // Damping for object movement after push
    let movableObjects = []; // Array to hold objects that can be pushed

    init();
    animate();

    function init() {
        console.log('üöÄ Initialisation de l\'exp√©rience VR...');

        // Sc√®ne avec am√©liorations
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000015, 30, 150);

        // Cam√©ra optimis√©e pour VR mobile
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5); // Player height
        lastCameraPosition.copy(camera.position); // Initialiser la derni√®re position de la cam√©ra

        // Renderer avec optimisations
        renderer = new THREE.WebGLRenderer({
            antialias: window.devicePixelRatio < 2,
            powerPreference: "high-performance",
            alpha: false
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000015);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Configuration des contr√¥les
        setupControls();
        setupDeviceOrientation();
        setupFullscreenHandlers();

        // √âclairage am√©lior√©
        setupLighting();

        // Cr√©ation du monde
        createFloatingCubes();
        createFloatingSpheres();
        createParticleSystem();
        createEnvironment();

        // √âv√©nements
        setupEventListeners();

        // V√©rification des permissions
        checkGyroPermission();

        console.log('‚úÖ Initialisation termin√©e');
    }

    function setupControls() {
        const vrToggle = document.getElementById('vrToggle');
        const resetView = document.getElementById('resetView');
        const calibrate = document.getElementById('calibrate');

        vrToggle.addEventListener('click', toggleVRMode);
        resetView.addEventListener('click', resetCameraView);
        calibrate.addEventListener('click', calibrateOrientation);
    }

    function setupFullscreenHandlers() {
        document.addEventListener('fullscreenchange', updateFullscreenStatus);
        document.addEventListener('webkitfullscreenchange', updateFullscreenStatus);
        document.addEventListener('mozFullScreenChange', updateFullscreenStatus);
        document.addEventListener('MSFullscreenChange', updateFullscreenStatus);
    }

    function updateFullscreenStatus() {
        isFullscreen = !!(document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement);

        const status = document.getElementById('fullscreen-status');
        if (status) {
            status.className = isFullscreen ? 'status-dot active' : 'status-dot';
        }
    }

    function setupLighting() {
        // √âclairage ambiant
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        // Lumi√®re directionnelle avec ombres
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // Lumi√®res color√©es anim√©es
        const light1 = new THREE.PointLight(0xff6b35, 1, 25);
        light1.position.set(-8, 6, -8);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x4ecdc4, 1, 25);
        light2.position.set(8, 6, 8);
        scene.add(light2);

        const light3 = new THREE.PointLight(0x45b7d1, 0.8, 20);
        light3.position.set(0, 8, -12);
        scene.add(light3);
    }

    function checkGyroPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('gyro-permission').style.display = 'flex';
        } else if (window.DeviceOrientationEvent) {
            // Android ou navigateurs qui ne n√©cessitent pas de permission explicite
            setupDeviceOrientation();
            document.getElementById('gyro-permission').style.display = 'none';
        } else {
            console.warn('‚ö†Ô∏è DeviceOrientation non support√©');
            updateGyroStatus(false);
        }
    }

    function requestGyroPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    console.log('üì± R√©ponse permission gyroscope:', response);
                    if (response === 'granted') {
                        gyroPermissionGranted = true;
                        document.getElementById('gyro-permission').style.display = 'none';
                        setupDeviceOrientation();
                        updateGyroStatus(true);
                    } else {
                        console.warn('‚ùå Permission gyroscope refus√©e');
                        updateGyroStatus(false);
                        document.getElementById('gyro-permission').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('‚ùå Erreur permission gyroscope:', error);
                    updateGyroStatus(false);
                    document.getElementById('gyro-permission').style.display = 'none';
                });
        } else {
            skipGyroPermission();
        }
    }

    function skipGyroPermission() {
        document.getElementById('gyro-permission').style.display = 'none';
        setupDeviceOrientation();
    }

    function setupDeviceOrientation() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', onDeviceOrientation, true);
            deviceOrientationEnabled = true;
            console.log('‚úÖ Gyroscope configur√©');
            updateGyroStatus(true);
        } else {
            console.warn('‚ö†Ô∏è DeviceOrientation non disponible');
            updateGyroStatus(false);
        }
    }

    function onDeviceOrientation(event) {
        if (!deviceOrientationEnabled) return;

        if (event.alpha === null || event.beta === null || event.gamma === null) {
            return;
        }

        const newAlpha = event.alpha || 0;
        const newBeta = event.beta || 0;
        const newGamma = event.gamma || 0;

        orientationData.alpha = newAlpha;
        orientationData.beta = newBeta;
        orientationData.gamma = newGamma;

        orientationData.smoothAlpha = lerp(orientationData.smoothAlpha, orientationData.alpha, SMOOTHING_FACTOR);
        orientationData.smoothBeta = lerp(orientationData.smoothBeta, orientationData.beta, SMOOTHING_FACTOR);
        orientationData.smoothGamma = lerp(orientationData.smoothGamma, orientationData.gamma, SMOOTHING_FACTOR);

        if (Math.abs(newAlpha - orientationData.smoothAlpha) > ORIENTATION_THRESHOLD ||
            Math.abs(newBeta - orientationData.smoothBeta) > ORIENTATION_THRESHOLD ||
            Math.abs(newGamma - orientationData.smoothGamma) > ORIENTATION_THRESHOLD) {

            updateCameraFromOrientation();
        }
    }

    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function updateCameraFromOrientation() {
        if (!deviceOrientationEnabled) return;

        let alpha = orientationData.smoothAlpha - orientationCalibration.alpha;
        let gamma = orientationData.smoothGamma - orientationCalibration.gamma;

        alpha = normalizeAngle(alpha);
        gamma = Math.max(-90, Math.min(90, gamma));

        const alphaRad = THREE.MathUtils.degToRad(alpha);
        const gammaRad = THREE.MathUtils.degToRad(gamma);

        camera.rotation.order = 'YXZ';
        camera.rotation.y = alphaRad;
        camera.rotation.x = THREE.MathUtils.degToRad(orientationData.smoothBeta - orientationCalibration.beta); // Use beta for vertical tilt
        camera.rotation.z = -gammaRad * 0.2; // Keep some roll effect
    }

    function normalizeAngle(angle) {
        while (angle > 180) angle -= 360;
        while (angle < -180) angle += 360;
        return angle;
    }

    function calibrateOrientation() {
        if (!deviceOrientationEnabled) {
            alert('‚ö†Ô∏è Gyroscope non disponible pour la calibration');
            return;
        }

        orientationCalibration = {
            alpha: orientationData.alpha,
            beta: orientationData.beta, // Calibrate beta too for consistent vertical view
            gamma: orientationData.gamma,
            isCalibrated: true
        };

        console.log('üéØ Orientation calibr√©e:', orientationCalibration);

        const btn = document.getElementById('calibrate');
        const originalText = btn.textContent;
        btn.textContent = '‚úÖ Calibr√©';
        btn.style.background = 'linear-gradient(45deg, #2ed573, #1e90ff)';

        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 2000);
    }

    function toggleVRMode() {
        const vrToggle = document.getElementById('vrToggle');
        const info = document.getElementById('info');
        const controls = document.getElementById('controls');
        const vrOverlay = document.getElementById('vrOverlay');
        const movementIndicator = document.getElementById('movement-indicator');

        isVRMode = !isVRMode;

        if (isVRMode) {
            console.log('ü•Ω Activation du mode VR');
            vrToggle.textContent = 'üëÅÔ∏è Mode Normal';
            vrToggle.classList.add('active');
            info.style.display = 'none';
            controls.style.display = 'none';
            vrOverlay.style.display = 'block';
            movementIndicator.style.display = 'block'; // Afficher l'indicateur

            if (!isFullscreen) {
                requestFullscreen();
            }

            // Masquer l'overlay apr√®s 3 secondes, l'indicateur reste visible
            setTimeout(() => {
                vrOverlay.style.display = 'none';
            }, 3000);

            isAutoMoving = true; // D√©marrer le mouvement automatique en VR
            updateMovementIndicator(); // Mettre √† jour l'indicateur
        } else {
            console.log('üëÅÔ∏è Retour au mode normal');
            vrToggle.textContent = 'ü•Ω Mode VR';
            vrToggle.classList.remove('active');
            info.style.display = 'block';
            controls.style.display = 'flex';
            vrOverlay.style.display = 'none';
            movementIndicator.style.display = 'none'; // Masquer l'indicateur

            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);

            isAutoMoving = false; // Arr√™ter le mouvement automatique
        }

        updateVRStatus(isVRMode);
    }

    function updateMovementIndicator() {
        const indicator = document.getElementById('movement-indicator');
        if (indicator) {
            if (isAutoMoving) {
                indicator.innerHTML = 'üö∂ Mouvement ON';
                indicator.style.opacity = 1;
                // Vous pouvez ajouter une animation pour indiquer le mouvement ici
            } else {
                indicator.innerHTML = 'üõë Mouvement OFF';
                indicator.style.opacity = 0.7;
            }
            indicator.style.display = 'block'; // S'assurer qu'il est visible
        }
    }

    function renderStereo() {
        if (!isVRMode) {
            renderer.render(scene, camera);
            return;
        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        const eyeSeparation = 0.032;

        renderer.setScissorTest(true);

        renderer.setScissor(0, 0, width / 2, height);
        renderer.setViewport(0, 0, width / 2, height);
        camera.position.x -= eyeSeparation;
        renderer.render(scene, camera);

        renderer.setScissor(width / 2, 0, width / 2, height);
        renderer.setViewport(width / 2, 0, width / 2, height);
        camera.position.x += eyeSeparation * 2;
        renderer.render(scene, camera);

        camera.position.x -= eyeSeparation;
    }

    function resetCameraView() {
        console.log('üéØ Remise √† z√©ro de la vue');
        camera.position.set(0, 1.6, 5); // Reset to initial player height
        camera.rotation.set(0, 0, 0);
        calibrateOrientation();
    }

    function toggleFullscreen() {
        if (!isFullscreen) {
            requestFullscreen();
        } else {
            exitFullscreen();
        }
    }

    function requestFullscreen() {
        const element = document.documentElement;
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

        if (isIOS) {
            if (document.body.webkitRequestFullscreen) {
                document.body.webkitRequestFullscreen();
            } else if (document.body.webkitEnterFullscreen) {
                document.body.webkitEnterFullscreen();
            }

            if (window.screen && window.screen.orientation && window.screen.orientation.lock) {
                window.screen.orientation.lock('landscape').catch(e => {
                    console.warn('Impossible de verrouiller l\'orientation:', e);
                });
            }
        } else {
            const requestMethod = element.requestFullscreen ||
                element.webkitRequestFullscreen ||
                element.mozRequestFullScreen ||
                element.msRequestFullscreen;

            if (requestMethod) {
                requestMethod.call(element);
            }
        }
    }

    function exitFullscreen() {
        const exitMethod = document.exitFullscreen ||
            document.webkitExitFullscreen ||
            document.mozCancelFullScreen ||
            document.msExitFullscreen;

        if (exitMethod) {
            exitMethod.call(document);
        }
    }

    function updateGyroStatus(active) {
        const status = document.getElementById('gyro-status');
        if (status) {
            status.className = active ? 'status-dot active' : 'status-dot';
        }
    }

    function updateVRStatus(active) {
        const status = document.getElementById('vr-status');
        if (status) {
            status.className = active ? 'status-dot active' : 'status-dot';
        }
    }

    function createFloatingCubes() {
        for (let i = 0; i < 20; i++) {
            const size = Math.random() * 1.5 + 0.5;
            const geometry = new THREE.BoxGeometry(size, size, size);

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });

            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;

            cube.position.set(
                (Math.random() - 0.5) * 40,
                size / 2, // Place on the ground
                (Math.random() - 0.5) * 40
            );

            cube.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            cube.userData = {
                originalColor: material.color.getHex(),
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                },
                isMovable: true, // Mark as movable for collision
                velocity: new THREE.Vector3() // For collision response
            };

            cubes.push(cube);
            movableObjects.push(cube); // Add to movable objects array
            scene.add(cube);
        }
    }

    function createFloatingSpheres() {
        for (let i = 0; i < 15; i++) {
            const radius = Math.random() * 1.2 + 0.3;
            const geometry = new THREE.SphereGeometry(radius, 16, 16);

            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.7,
                emissive: colors[Math.floor(Math.random() * colors.length)],
                emissiveIntensity: 0.2,
                shininess: 150
            });

            const sphere = new THREE.Mesh(geometry, material);
            sphere.castShadow = true;
            sphere.receiveShadow = true;

            sphere.position.set(
                (Math.random() - 0.5) * 35,
                radius, // Place on the ground
                (Math.random() - 0.5) * 35
            );

            sphere.userData = {
                originalColor: material.color.getHex(),
                originalEmissive: material.emissive.getHex(),
                pulseSpeed: Math.random() * 0.05 + 0.02,
                isMovable: true, // Mark as movable for collision
                velocity: new THREE.Vector3() // For collision response
            };

            spheres.push(sphere);
            movableObjects.push(sphere); // Add to movable objects array
            scene.add(sphere);
        }
    }

    function createParticleSystem() {
        const particleCount = 300;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            positions[i3] = (Math.random() - 0.5) * 120;
            positions[i3 + 1] = Math.random() * 60;
            positions[i3 + 2] = (Math.random() - 0.5) * 120;

            const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 1.5,
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        particles.push(particleSystem);
    }

    function createEnvironment() {
        // Sol avec grille am√©lior√©e
        const gridGeometry = new THREE.PlaneGeometry(120, 120, 60, 60);
        // Changed to MeshPhongMaterial to allow emissive properties
        const gridMaterial = new THREE.MeshPhongMaterial({
            color: 0x333366, // Dark blue/purple base color
            wireframe: true,
            transparent: true,
            opacity: 0.2,
            emissive: 0x000000, // Start with no emissive light
            emissiveIntensity: 0
        });

        floorMesh = new THREE.Mesh(gridGeometry, gridMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = 0;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);
        originalFloorColor = new THREE.Color(0x333366); // Store original color

        // Ciel √©toil√© am√©lior√©
        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(1500 * 3);
        const starColors = new Float32Array(1500 * 3);

        for (let i = 0; i < 1500; i++) {
            const i3 = i * 3;

            starPositions[i3] = (Math.random() - 0.5) * 300;
            starPositions[i3 + 1] = Math.random() * 150 + 20;
            starPositions[i3 + 2] = (Math.random() - 0.5) * 300;

            const intensity = Math.random();
            starColors[i3] = intensity;
            starColors[i3 + 1] = intensity;
            starColors[i3 + 2] = intensity;
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));

        const starsMaterial = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 0.9,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
    }

    function setupEventListeners() {
        window.addEventListener('resize', onWindowResize);

        // Simplifi√© pour la gestion du mouvement/interaction en VR
        let lastTouchTime = 0;
        window.addEventListener('touchend', (event) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTouchTime;

            if (isVRMode) {
                // Double tap pour quitter le mode VR
                if (tapLength < 500 && tapLength > 0) {
                    toggleVRMode();
                } else {
                    // Simple tap pour d√©marrer/arr√™ter le mouvement
                    isAutoMoving = !isAutoMoving;
                    updateMovementIndicator();
                }
            } else {
                // Comportement normal (clic/tap) si pas en mode VR
                if (event.touches && event.touches.length === 1) {
                    const touch = event.touches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    checkIntersection();
                } else if (!event.touches) { // Pour les clics de souris sur desktop
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    checkIntersection();
                }
            }
            lastTouchTime = currentTime;
        });

        window.addEventListener('orientationchange', () => {
            console.log('üì± Changement d\'orientation');
            setTimeout(detectScreenOrientation, 300);
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('‚è∏Ô∏è Application en arri√®re-plan');
            } else {
                console.log('‚ñ∂Ô∏è Application au premier plan');
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);

        frameCount++;
        const currentTime = performance.now();
        if (currentTime - lastTime >= 1000) {
            console.log(`üìä FPS: ${frameCount}`);
            frameCount = 0;
            lastTime = currentTime;
        }

        // Mouvement automatique si activ√© et en mode VR
        if (isVRMode && isAutoMoving) {
            moveCameraForward();
        }

        // Apply object velocities and damping
        movableObjects.forEach(object => {
            if (object.userData.velocity && object.userData.velocity.lengthSq() > 0.0001) {
                object.position.add(object.userData.velocity);
                object.userData.velocity.multiplyScalar(OBJECT_DAMPING); // Apply damping

                // Ensure objects stay on the ground
                if (object.geometry.type === "BoxGeometry") {
                    object.position.y = object.geometry.parameters.height / 2;
                } else if (object.geometry.type === "SphereGeometry") {
                    object.position.y = object.geometry.parameters.radius;
                }
            }
        });

        render();
    }

    function moveCameraForward() {
        const oldCameraPosition = camera.position.clone();

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0; // Prevent vertical movement from head tilt
        direction.normalize();

        // Calculate potential new position
        const newCameraPosition = camera.position.clone().addScaledVector(direction, MOVEMENT_SPEED);

        // Check for collisions with movable objects
        let collisionDetected = false;
        movableObjects.forEach(object => {
            const objectRadius = object.geometry.type === "BoxGeometry" ?
                Math.max(object.geometry.parameters.width, object.geometry.parameters.depth) / 2 :
                object.geometry.parameters.radius;

            const distance = newCameraPosition.distanceTo(object.position);
            const combinedRadius = PLAYER_RADIUS + objectRadius;

            if (distance < combinedRadius) {
                collisionDetected = true;
                const collisionNormal = newCameraPosition.clone().sub(object.position).normalize();

                // Push object away
                const overlap = combinedRadius - distance;
                const pushVector = collisionNormal.clone().multiplyScalar(-overlap * OBJECT_PUSH_FORCE); // Push object in opposite direction
                object.userData.velocity.add(pushVector); // Apply velocity to object

                // Adjust camera position to prevent penetration
                const cameraAdjust = collisionNormal.clone().multiplyScalar(overlap);
                camera.position.add(cameraAdjust); // Move camera back slightly
            }
        });

        // If no collision, move camera normally
        if (!collisionDetected) {
            camera.position.copy(newCameraPosition);
        }

        if (camera.position.y < 1.6) {
            camera.position.y = 1.6;
        }

        // Check for "step" to trigger floor effect
        if (camera.position.distanceTo(lastCameraPosition) > STEP_DISTANCE_THRESHOLD) {
            triggerFloorEffect(camera.position.clone());
            lastCameraPosition.copy(camera.position);
        }
    }


    function triggerFloorEffect(position) {
        if (!floorMesh) return;

        const originalEmissive = floorMesh.material.emissive.clone();
        const originalEmissiveIntensity = floorMesh.material.emissiveIntensity;

        // Brightest point for the flash
        const flashColor = new THREE.Color(0x88CCFF); // A bright, slightly blueish color
        const flashIntensity = 2.0; // How bright it gets

        const startTime = Date.now();

        function animateFloorEffect() {
            const elapsedTime = Date.now() - startTime;
            const progress = elapsedTime / FLOOR_EFFECT_DURATION;

            if (progress < 1) {
                // Interpolate emissive color and intensity
                floorMesh.material.emissive.lerpColors(flashColor, originalEmissive, progress);
                floorMesh.material.emissiveIntensity = lerp(flashIntensity, originalEmissiveIntensity, progress);

                // Emitter particles when fading back
                if (progress > 0.5 && Math.random() < 0.2) { // Start emitting particles halfway through fade
                    createRisingParticles(position);
                }

                requestAnimationFrame(animateFloorEffect);
            } else {
                // Ensure it reverts to original state
                floorMesh.material.emissive.copy(originalEmissive);
                floorMesh.material.emissiveIntensity = originalEmissiveIntensity;
            }
        }
        animateFloorEffect();
    }

    function createRisingParticles(originPosition) {
        const particleCount = 15; // Number of particles per burst
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colorsArray = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const lifetimes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            // Start near the origin position, slightly varied on the floor
            positions[i3] = originPosition.x + (Math.random() - 0.5) * 0.5;
            positions[i3 + 1] = 0.1; // Slightly above the floor
            positions[i3 + 2] = originPosition.z + (Math.random() - 0.5) * 0.5;

            // Random color, similar to sky stars
            const intensity = Math.random();
            colorsArray[i3] = intensity;
            colorsArray[i3 + 1] = intensity;
            colorsArray[i3 + 2] = intensity;

            // Velocity: primarily upwards, with slight horizontal variations
            velocities[i3] = (Math.random() - 0.5) * 0.01;
            velocities[i3 + 1] = Math.random() * 0.05 + 0.01; // Rise upwards
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;

            lifetimes[i] = Math.random() * 1.5 + 0.5; // Particle lifetime in seconds
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
        geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1)); // Single value per particle

        const material = new THREE.PointsMaterial({
            size: 1.0, // Slightly smaller than sky stars
            transparent: true,
            opacity: 1.0,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const risingParticles = new THREE.Points(geometry, material);
        scene.add(risingParticles);

        const effectStartTime = clock.getElapsedTime();

        function animateRisingParticles() {
            const currentTime = clock.getElapsedTime();
            const positions = risingParticles.geometry.attributes.position.array;
            const velocities = risingParticles.geometry.attributes.velocity.array;
            const lifetimes = risingParticles.geometry.attributes.lifetime.array;
            const colors = risingParticles.geometry.attributes.color.array;

            let particlesAlive = 0;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const particleLifetime = lifetimes[i];
                const age = currentTime - effectStartTime;

                if (age < particleLifetime) {
                    positions[i3] += velocities[i3];
                    positions[i3 + 1] += velocities[i3 + 1];
                    positions[i3 + 2] += velocities[i3 + 2];

                    // Fade out as it ages
                    const fadeProgress = age / particleLifetime;
                    material.opacity = 1.0 - fadeProgress; // Apply fading to the material, affects all particles
                    // For individual particle fading, you'd need a custom shader or per-particle opacity
                    particlesAlive++;
                } else {
                    // Make particle invisible or reposition if it's dead
                    positions[i3] = positions[i3 + 1] = positions[i3 + 2] = 10000; // Move far away
                }
            }

            risingParticles.geometry.attributes.position.needsUpdate = true;
            risingParticles.material.opacity = material.opacity; // Update material opacity for fading

            if (particlesAlive > 0) {
                requestAnimationFrame(animateRisingParticles);
            } else {
                scene.remove(risingParticles);
                geometry.dispose();
                material.dispose();
            }
        }
        animateRisingParticles();
    }


    function render() {
        const time = clock.getElapsedTime();

        cubes.forEach((cube) => {
            const userData = cube.userData;
            // Only rotate if not significantly pushed
            if (userData.velocity.lengthSq() < 0.01) {
                cube.rotation.x += userData.rotationSpeed.x;
                cube.rotation.y += userData.rotationSpeed.y;
                cube.rotation.z += userData.rotationSpeed.z;
            }
            // Cubes are now ground-based, no floating Y animation
        });

        spheres.forEach((sphere) => {
            const userData = sphere.userData;
            const scale = 1 + Math.sin(time * userData.pulseSpeed) * 0.15;
            sphere.scale.setScalar(scale);
            const emissiveIntensity = 0.1 + Math.sin(time * userData.pulseSpeed * 2) * 0.1;
            sphere.material.emissiveIntensity = emissiveIntensity;
            // Spheres are now ground-based, no floating Y/X animation
        });

        particles.forEach(particleSystem => {
            particleSystem.rotation.y += 0.0005;
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(time * 0.001 + positions[i] * 0.01) * 0.02;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        });

        renderStereo();
    }

    function onMouseClick(event) {
        // Cette fonction n'est plus appel√©e directement pour l'interaction en VR
        // Elle est toujours l√† pour les interactions hors VR si besoin
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        checkIntersection();
    }

    function onTouchStart(event) {
        event.preventDefault(); // Emp√™che le d√©filement et le zoom
        // La logique de tap est maintenant dans `touchend`
    }

    function checkIntersection() {
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects([...cubes, ...spheres]);

        if (intersects.length > 0) {
            const object = intersects[0].object;

            const originalColor = object.userData.originalColor;

            object.material.color.setHex(0xffffff);
            object.scale.setScalar(1.5);

            createSelectionEffect(object.position);

            setTimeout(() => {
                object.material.color.setHex(originalColor);
                object.scale.setScalar(1);
            }, 800);
        }
    }

    function createSelectionEffect(position) {
        const particleCount = 20;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = position.x + (Math.random() - 0.5) * 2;
            positions[i + 1] = position.y + (Math.random() - 0.5) * 2;
            positions[i + 2] = position.z + (Math.random() - 0.5) * 2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 3,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending
        });

        const effect = new THREE.Points(geometry, material);
        scene.add(effect);

        const startTime = performance.now();
        const duration = 1000;

        function animateEffect() {
            const elapsed = performance.now() - startTime;
            const progress = elapsed / duration;

            if (progress < 1) {
                material.opacity = 1 - progress;
                effect.scale.setScalar(1 + progress * 2);
                requestAnimationFrame(animateEffect);
            } else {
                scene.remove(effect);
                geometry.dispose();
                material.dispose();
            }
        }

        animateEffect();
    }

    function detectScreenOrientation() {
        if (window.innerHeight > window.innerWidth) {
            if (screenOrientation !== 'portrait') {
                screenOrientation = 'portrait';
                console.log('üì± Orientation: portrait');
                document.getElementById('orientation-warning').style.display = 'flex';
            }
        } else {
            if (screenOrientation !== 'landscape') {
                screenOrientation = 'landscape';
                console.log('üì± Orientation: paysage');
                document.getElementById('orientation-warning').style.display = 'none';
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        console.log('üì± Redimensionnement:', window.innerWidth, 'x', window.innerHeight);

        detectScreenOrientation();
    }

    updateGyroStatus(false);
    updateVRStatus(false);
    updateFullscreenStatus();

    console.log('üéÆ Application VR pr√™te !');
</script>
</body>
</html>