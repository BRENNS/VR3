<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gyroscope Corrigé - Vue 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
        }

        #cube {
            width: 200px;
            height: 200px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.1s ease-out;
        }

        .face {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 2px solid #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .front { background: rgba(255, 0, 0, 0.8); transform: rotateY(0deg) translateZ(100px); }
        .back { background: rgba(0, 255, 0, 0.8); transform: rotateY(180deg) translateZ(100px); }
        .right { background: rgba(0, 0, 255, 0.8); transform: rotateY(90deg) translateZ(100px); }
        .left { background: rgba(255, 255, 0, 0.8); transform: rotateY(-90deg) translateZ(100px); }
        .top { background: rgba(255, 0, 255, 0.8); transform: rotateX(90deg) translateZ(100px); }
        .bottom { background: rgba(0, 255, 255, 0.8); transform: rotateX(-90deg) translateZ(100px); }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
        }

        #info {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            font-family: monospace;
        }

        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider {
            width: 100%;
            margin: 5px 0;
        }

        #status {
            color: #4CAF50;
            font-weight: bold;
        }

        .error {
            color: #ff4444;
        }

        .warning {
            color: #ffaa00;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="cube">
        <div class="face front">AVANT</div>
        <div class="face back">ARRIÈRE</div>
        <div class="face right">DROITE</div>
        <div class="face left">GAUCHE</div>
        <div class="face top">HAUT</div>
        <div class="face bottom">BAS</div>
    </div>
</div>

<div id="controls">
    <h3>Contrôles Gyroscope</h3>
    <button id="startBtn">Démarrer Gyroscope</button>
    <button id="stopBtn" disabled>Arrêter</button>
    <button id="calibrateBtn">Calibrer</button>
    <button id="resetBtn">Reset Position</button>
    <button id="fullscreenBtn">Plein Écran</button>

    <div class="slider-container">
        <label>Sensibilité X: <span id="sensXValue">1.0</span></label>
        <input type="range" id="sensX" class="slider" min="0.1" max="3.0" step="0.1" value="1.0">
    </div>

    <div class="slider-container">
        <label>Sensibilité Y: <span id="sensYValue">1.0</span></label>
        <input type="range" id="sensY" class="slider" min="0.1" max="3.0" step="0.1" value="1.0">
    </div>

    <div class="slider-container">
        <label>Sensibilité Z: <span id="sensZValue">1.0</span></label>
        <input type="range" id="sensZ" class="slider" min="0.1" max="3.0" step="0.1" value="1.0">
    </div>

    <div>
        <input type="checkbox" id="invertX"> <label for="invertX">Inverser X</label><br>
        <input type="checkbox" id="invertY" checked> <label for="invertY">Inverser Y</label><br>
        <input type="checkbox" id="invertZ"> <label for="invertZ">Inverser Z</label>
    </div>
</div>

<div id="info">
    <div id="status">Gyroscope non démarré</div>
    <div>Rotation X: <span id="rotX">0°</span></div>
    <div>Rotation Y: <span id="rotY">0°</span></div>
    <div>Rotation Z: <span id="rotZ">0°</span></div>
    <div>Gyro X: <span id="gyroX">0</span></div>
    <div>Gyro Y: <span id="gyroY">0</span></div>
    <div>Gyro Z: <span id="gyroZ">0</span></div>
</div>

<script>
    class GyroscopeController {
        constructor() {
            this.cube = document.getElementById('cube');
            this.isActive = false;
            this.rotationX = 0;
            this.rotationY = 0;
            this.rotationZ = 0;

            // Calibration
            this.calibrationX = 0;
            this.calibrationY = 0;
            this.calibrationZ = 0;
            this.isCalibrating = false;
            this.calibrationSamples = [];

            // Sensibilité
            this.sensitivityX = 1.0;
            this.sensitivityY = 1.0;
            this.sensitivityZ = 1.0;

            // Inversion des axes
            this.invertX = false;
            this.invertY = true; // Inverser Y par défaut pour corriger le problème du plafond
            this.invertZ = false;

            // Filtrage
            this.alpha = 0.8; // Filtre passe-bas
            this.lastRotationX = 0;
            this.lastRotationY = 0;
            this.lastRotationZ = 0;

            this.initializeControls();
            this.checkGyroscopeSupport();
        }

        checkGyroscopeSupport() {
            const status = document.getElementById('status');

            if (!window.DeviceOrientationEvent) {
                status.textContent = 'Gyroscope non supporté';
                status.className = 'error';
                return false;
            }

            // Vérifier si on a besoin de permissions (iOS 13+)
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                status.textContent = 'Permission requise pour iOS';
                status.className = 'warning';
            } else {
                status.textContent = 'Gyroscope supporté';
                status.className = '';
            }

            return true;
        }

        async requestPermission() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission !== 'granted') {
                        throw new Error('Permission refusée');
                    }
                } catch (error) {
                    console.error('Erreur permission:', error);
                    document.getElementById('status').textContent = 'Permission refusée';
                    document.getElementById('status').className = 'error';
                    return false;
                }
            }
            return true;
        }

        initializeControls() {
            // Boutons
            document.getElementById('startBtn').addEventListener('click', () => this.start());
            document.getElementById('stopBtn').addEventListener('click', () => this.stop());
            document.getElementById('calibrateBtn').addEventListener('click', () => this.calibrate());
            document.getElementById('resetBtn').addEventListener('click', () => this.reset());
            document.getElementById('fullscreenBtn').addEventListener('click', () => this.toggleFullscreen());

            // Sliders de sensibilité
            document.getElementById('sensX').addEventListener('input', (e) => {
                this.sensitivityX = parseFloat(e.target.value);
                document.getElementById('sensXValue').textContent = this.sensitivityX.toFixed(1);
            });

            document.getElementById('sensY').addEventListener('input', (e) => {
                this.sensitivityY = parseFloat(e.target.value);
                document.getElementById('sensYValue').textContent = this.sensitivityY.toFixed(1);
            });

            document.getElementById('sensZ').addEventListener('input', (e) => {
                this.sensitivityZ = parseFloat(e.target.value);
                document.getElementById('sensZValue').textContent = this.sensitivityZ.toFixed(1);
            });

            // Checkboxes d'inversion
            document.getElementById('invertX').addEventListener('change', (e) => {
                this.invertX = e.target.checked;
            });

            document.getElementById('invertY').addEventListener('change', (e) => {
                this.invertY = e.target.checked;
            });

            document.getElementById('invertZ').addEventListener('change', (e) => {
                this.invertZ = e.target.checked;
            });
        }

        async start() {
            if (!await this.requestPermission()) {
                return;
            }

            this.isActive = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('status').textContent = 'Gyroscope actif';
            document.getElementById('status').className = '';

            window.addEventListener('deviceorientation', this.handleOrientation.bind(this));
        }

        stop() {
            this.isActive = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').textContent = 'Gyroscope arrêté';

            window.removeEventListener('deviceorientation', this.handleOrientation.bind(this));
        }

        handleOrientation(event) {
            if (!this.isActive) return;

            // Récupérer les valeurs brutes
            let alpha = event.alpha || 0; // Z axis (0-360)
            let beta = event.beta || 0;   // X axis (-180 to 180)
            let gamma = event.gamma || 0; // Y axis (-90 to 90)

            // Appliquer la calibration
            alpha -= this.calibrationZ;
            beta -= this.calibrationX;
            gamma -= this.calibrationY;

            // Normaliser les angles
            alpha = this.normalizeAngle(alpha);
            beta = this.normalizeAngle(beta);
            gamma = this.normalizeAngle(gamma);

            // Appliquer les inversions et sensibilités
            let rotX = beta * this.sensitivityX * (this.invertX ? -1 : 1);
            let rotY = gamma * this.sensitivityY * (this.invertY ? -1 : 1);
            let rotZ = alpha * this.sensitivityZ * (this.invertZ ? -1 : 1);

            // Appliquer un filtre passe-bas pour lisser les mouvements
            rotX = this.alpha * this.lastRotationX + (1 - this.alpha) * rotX;
            rotY = this.alpha * this.lastRotationY + (1 - this.alpha) * rotY;
            rotZ = this.alpha * this.lastRotationZ + (1 - this.alpha) * rotZ;

            // Limiter les rotations pour éviter les retournements
            rotX = Math.max(-85, Math.min(85, rotX));
            rotY = Math.max(-85, Math.min(85, rotY));

            this.lastRotationX = rotX;
            this.lastRotationY = rotY;
            this.lastRotationZ = rotZ;

            this.rotationX = rotX;
            this.rotationY = rotY;
            this.rotationZ = rotZ;

            this.updateCube();
            this.updateInfo(event);
        }

        normalizeAngle(angle) {
            while (angle > 180) angle -= 360;
            while (angle < -180) angle += 360;
            return angle;
        }

        updateCube() {
            // Utiliser une rotation corrigée pour éviter le problème du plafond
            const transform = `rotateX(${this.rotationX}deg) rotateY(${this.rotationY}deg) rotateZ(${this.rotationZ}deg)`;
            this.cube.style.transform = transform;
        }

        updateInfo(event) {
            document.getElementById('rotX').textContent = `${this.rotationX.toFixed(1)}°`;
            document.getElementById('rotY').textContent = `${this.rotationY.toFixed(1)}°`;
            document.getElementById('rotZ').textContent = `${this.rotationZ.toFixed(1)}°`;
            document.getElementById('gyroX').textContent = (event.beta || 0).toFixed(1);
            document.getElementById('gyroY').textContent = (event.gamma || 0).toFixed(1);
            document.getElementById('gyroZ').textContent = (event.alpha || 0).toFixed(1);
        }

        calibrate() {
            if (!this.isActive) {
                alert('Démarrez d\'abord le gyroscope');
                return;
            }

            this.isCalibrating = true;
            this.calibrationSamples = [];
            document.getElementById('status').textContent = 'Calibration... (3s)';
            document.getElementById('status').className = 'warning';

            // Collecter des échantillons pendant 3 secondes
            const startTime = Date.now();
            const calibrationInterval = setInterval(() => {
                if (Date.now() - startTime > 3000) {
                    clearInterval(calibrationInterval);
                    this.finishCalibration();
                }
            }, 100);
        }

        finishCalibration() {
            if (this.calibrationSamples.length > 0) {
                // Calculer la moyenne des échantillons
                const avgX = this.calibrationSamples.reduce((sum, sample) => sum + sample.x, 0) / this.calibrationSamples.length;
                const avgY = this.calibrationSamples.reduce((sum, sample) => sum + sample.y, 0) / this.calibrationSamples.length;
                const avgZ = this.calibrationSamples.reduce((sum, sample) => sum + sample.z, 0) / this.calibrationSamples.length;

                this.calibrationX = avgX;
                this.calibrationY = avgY;
                this.calibrationZ = avgZ;

                document.getElementById('status').textContent = 'Calibration terminée';
                document.getElementById('status').className = '';
            } else {
                document.getElementById('status').textContent = 'Échec calibration';
                document.getElementById('status').className = 'error';
            }

            this.isCalibrating = false;
        }

        reset() {
            this.rotationX = 0;
            this.rotationY = 0;
            this.rotationZ = 0;
            this.calibrationX = 0;
            this.calibrationY = 0;
            this.calibrationZ = 0;
            this.lastRotationX = 0;
            this.lastRotationY = 0;
            this.lastRotationZ = 0;
            this.updateCube();
            document.getElementById('status').textContent = 'Position réinitialisée';
        }

        toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error('Erreur plein écran:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }
    }

    // Initialiser l'application
    document.addEventListener('DOMContentLoaded', () => {
        new GyroscopeController();
    });

    // Gestion du plein écran
    document.addEventListener('fullscreenchange', () => {
        const btn = document.getElementById('fullscreenBtn');
        btn.textContent = document.fullscreenElement ? 'Quitter Plein Écran' : 'Plein Écran';
    });

    // Gestion des erreurs
    window.addEventListener('error', (e) => {
        console.error('Erreur:', e.error);
        document.getElementById('status').textContent = 'Erreur: ' + e.error.message;
        document.getElementById('status').className = 'error';
    });
</script>
</body>
</html>
