<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Exp√©rience VR Mobile Am√©lior√©e</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn {
            padding: 12px 20px;
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
            transition: all 0.3s ease;
            min-width: 100px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-btn:hover, .control-btn:active {
            background: linear-gradient(45deg, #e55a2b, #e8851d);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
        }

        .control-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 24px;
            text-align: center;
            animation: pulse 2s infinite;
        }

        #gyro-permission {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        #status-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .status-item {
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4757;
        }

        .status-dot.active {
            background: #2ed573;
            animation: blink 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @media (orientation: portrait) and (max-width: 768px) {
            #orientation-warning {
                display: flex;
            }
        }

        @media (orientation: landscape) {
            #orientation-warning {
                display: none;
            }
        }

        .vr-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 50;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.8);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .fullscreen-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Indicateur de mouvement */
        #movement-indicator {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 10;
            display: none; /* Masqu√© par d√©faut */
            transition: opacity 0.3s ease;
        }

        #score-display {
            position: absolute;
            top: 60px; /* Below info box */
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 16px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
<div id="orientation-warning">
    <div style="font-size: 48px; margin-bottom: 20px;">üì±</div>
    <h2>Tournez votre t√©l√©phone</h2>
    <p>Basculez en mode paysage pour une exp√©rience VR optimale</p>
    <div style="margin-top: 20px; font-size: 16px; opacity: 0.8;">
        Meilleure exp√©rience avec un casque VR mobile
    </div>
</div>

<div id="gyro-permission">
    <div style="font-size: 48px; margin-bottom: 20px;">üß≠</div>
    <h2>Permission Gyroscope Requise</h2>
    <p>Autorisez l'acc√®s au gyroscope pour contr√¥ler la cam√©ra avec les mouvements de votre t√™te</p>
    <p style="font-size: 14px; opacity: 0.8; margin: 20px 0;">
        Cette permission est n√©cessaire pour une exp√©rience VR immersive
    </p>
    <button class="control-btn" onclick="requestGyroPermission()">Autoriser le Gyroscope</button>
    <button class="control-btn" onclick="skipGyroPermission()" style="margin-top: 10px; opacity: 0.7;">
        Continuer sans gyroscope
    </button>
</div>

<button class="fullscreen-btn" onclick="toggleFullscreen()" title="Plein √©cran">
    ‚õ∂
</button>

<div id="status-indicator">
    <div class="status-item">
        <div class="status-dot" id="gyro-status"></div>
        <span>Gyroscope</span>
    </div>
    <div class="status-item">
        <div class="status-dot" id="vr-status"></div>
        <span>Mode VR</span>
    </div>
    <div class="status-item">
        <div class="status-dot" id="fullscreen-status"></div>
        <span>Plein √©cran</span>
    </div>
</div>

<div id="info">
    <h3>üöÄ VR Mobile - Exp√©rience Immersive</h3>
    <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px;">
        <strong>Instructions:</strong>
        <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
            <li>Placez votre t√©l√©phone dans un casque VR</li>
            <li>Activez le mode VR pour l'√©cran divis√©</li>
            <li>Bougez la t√™te pour regarder autour</li>
            <li>En mode VR, touchez l'√©cran pour d√©marrer/arr√™ter le mouvement</li>
            <li>Tapez deux fois pour quitter le mode VR</li>
        </ul>
    </div>
    <div style="font-size: 11px; opacity: 0.7;">
        Optimis√© pour iPhone et Android
    </div>
</div>

<div id="score-display">
    Collect√©s: <span id="collected-count">0</span>
</div>

<div id="controls">
    <button id="vrToggle" class="control-btn">ü•Ω Mode VR</button>
    <button id="resetView" class="control-btn">üéØ Recentrer</button>
    <button id="calibrate" class="control-btn">‚öôÔ∏è Calibrer</button>
</div>

<div class="vr-overlay" id="vrOverlay">
    <h3>Mode VR Activ√©</h3>
    <p>Placez votre t√©l√©phone dans le casque VR</p>
    <p style="font-size: 14px; opacity: 0.8;">Tapez une fois pour d√©marrer/arr√™ter le mouvement</p>
    <p style="font-size: 14px; opacity: 0.8;">Tapez deux fois pour quitter le mode VR</p>
</div>

<div id="movement-indicator">
    <span>üö∂ Mouvement ON</span>
</div>

<div id="canvas-container"></div>

<script>
    // Configuration avanc√©e
    let scene, camera, renderer;
    let cubes = [], spheres = [], particles = [];
    let raycaster = new THREE.Raycaster();
    let clock = new THREE.Clock();
    let mouse = new THREE.Vector2();

    // Variables VR et gyroscope am√©lior√©es
    let isVRMode = false;
    let deviceOrientationEnabled = false;
    let gyroPermissionGranted = false;
    let isFullscreen = false;
    let screenOrientation = 'portrait';

    // Syst√®me de calibrage am√©lior√©
    let orientationCalibration = {
        alpha: 0,
        beta: 0,
        gamma: 0,
        isCalibrated: false
    };

    // Contr√¥les gyroscope avec filtrage
    let orientationData = {
        alpha: 0,
        beta: 0,
        gamma: 0,
        smoothAlpha: 0,
        smoothBeta: 0,
        smoothGamma: 0
    };

    // Param√®tres de lissage
    const SMOOTHING_FACTOR_ORIENTATION = 0.25; // For head rotation
    const SMOOTHING_FACTOR_MOVEMENT = 0.1; // For camera position movement
    const ORIENTATION_THRESHOLD = 0.2;

    // Variables de mouvement automatique en VR
    let isAutoMoving = false;
    const MOVEMENT_SPEED = 0.08; // Adjusted for smoother default movement
    const PLAYER_HEIGHT = 1.6; // Initial player height

    // Variables pour l'effet du sol
    let floorMesh;
    let originalFloorColor;
    let lastCameraPosition = new THREE.Vector3();
    const STEP_DISTANCE_THRESHOLD = 1.0;
    const FLOOR_EFFECT_DURATION = 3000;

    // Mat√©riaux et couleurs am√©lior√©s
    const colors = [
        0xff6b35, 0x4ecdc4, 0x45b7d1, 0x96ceb4,
        0xfeca57, 0xff9ff3, 0x54a0ff, 0x5f27cd,
        0x00d2d3, 0xff9f43, 0x10ac84, 0xee5a24
    ];

    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();

    // Collision variables
    const PLAYER_RADIUS = 0.5; // Approximate radius of the player/camera
    const OBJECT_PUSH_FORCE = 0.05; // Reduced for smoother pushes
    const OBJECT_DAMPING = 0.95; // Increased damping for faster stop

    let movableObjects = []; // Array to hold objects that can be pushed AND collected

    // Collectible variables
    let collectedCount = 0;
    const MAX_CUBES = 20;
    const MAX_SPHERES = 15;
    const GROW_FACTOR_PER_COLLECTIBLE = 0.02; // How much player grows per collectible
    let currentScale = 1.0;

    init();
    animate();

    function init() {
        console.log('üöÄ Initialisation de l\'exp√©rience VR...');

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000015, 30, 150);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, PLAYER_HEIGHT, 5); // Player height
        lastCameraPosition.copy(camera.position);

        renderer = new THREE.WebGLRenderer({
            antialias: window.devicePixelRatio < 2,
            powerPreference: "high-performance",
            alpha: false
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000015);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.getElementById('canvas-container').appendChild(renderer.domElement);

        setupControls();
        setupDeviceOrientation();
        setupFullscreenHandlers();
        setupLighting();
        createParticleSystem();
        createEnvironment();

        // Initial creation of cubes and spheres
        for (let i = 0; i < MAX_CUBES; i++) {
            createCube(true); // true to indicate initial creation
        }
        for (let i = 0; i < MAX_SPHERES; i++) {
            createSphere(true); // true to indicate initial creation
        }

        setupEventListeners();
        checkGyroPermission();

        updateScoreDisplay(); // Initialize score display

        console.log('‚úÖ Initialisation termin√©e');
    }

    function setupControls() {
        const vrToggle = document.getElementById('vrToggle');
        const resetView = document.getElementById('resetView');
        const calibrate = document.getElementById('calibrate');

        vrToggle.addEventListener('click', toggleVRMode);
        resetView.addEventListener('click', resetCameraView);
        calibrate.addEventListener('click', calibrateOrientation);
    }

    function setupFullscreenHandlers() {
        document.addEventListener('fullscreenchange', updateFullscreenStatus);
        document.addEventListener('webkitfullscreenchange', updateFullscreenStatus);
        document.addEventListener('mozFullScreenChange', updateFullscreenStatus);
        document.addEventListener('MSFullscreenChange', updateFullscreenStatus);
    }

    function updateFullscreenStatus() {
        isFullscreen = !!(document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement);

        const status = document.getElementById('fullscreen-status');
        if (status) {
            status.className = isFullscreen ? 'status-dot active' : 'status-dot';
        }
    }

    function setupLighting() {
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        const light1 = new THREE.PointLight(0xff6b35, 1, 25);
        light1.position.set(-8, 6, -8);
        scene.add(light1);

        const light2 = new THREE.PointLight(0x4ecdc4, 1, 25);
        light2.position.set(8, 6, 8);
        scene.add(light2);

        const light3 = new THREE.PointLight(0x45b7d1, 0.8, 20);
        light3.position.set(0, 8, -12);
        scene.add(light3);
    }

    function checkGyroPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.getElementById('gyro-permission').style.display = 'flex';
        } else if (window.DeviceOrientationEvent) {
            setupDeviceOrientation();
            document.getElementById('gyro-permission').style.display = 'none';
        } else {
            console.warn('‚ö†Ô∏è DeviceOrientation non support√©');
            updateGyroStatus(false);
        }
    }

    function requestGyroPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    console.log('üì± R√©ponse permission gyroscope:', response);
                    if (response === 'granted') {
                        gyroPermissionGranted = true;
                        document.getElementById('gyro-permission').style.display = 'none';
                        setupDeviceOrientation();
                        updateGyroStatus(true);
                    } else {
                        console.warn('‚ùå Permission gyroscope refus√©e');
                        updateGyroStatus(false);
                        document.getElementById('gyro-permission').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('‚ùå Erreur permission gyroscope:', error);
                    updateGyroStatus(false);
                    document.getElementById('gyro-permission').style.display = 'none';
                });
        } else {
            skipGyroPermission();
        }
    }

    function skipGyroPermission() {
        document.getElementById('gyro-permission').style.display = 'none';
        setupDeviceOrientation();
    }

    function setupDeviceOrientation() {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', onDeviceOrientation, true);
            deviceOrientationEnabled = true;
            console.log('‚úÖ Gyroscope configur√©');
            updateGyroStatus(true);
        } else {
            console.warn('‚ö†Ô∏è DeviceOrientation non disponible');
            updateGyroStatus(false);
        }
    }

    function onDeviceOrientation(event) {
        if (!deviceOrientationEnabled) return;

        if (event.alpha === null || event.beta === null || event.gamma === null) {
            return;
        }

        const newAlpha = event.alpha || 0;
        const newBeta = event.beta || 0;
        const newGamma = event.gamma || 0;

        orientationData.alpha = newAlpha;
        orientationData.beta = newBeta;
        orientationData.gamma = newGamma;

        orientationData.smoothAlpha = lerp(orientationData.smoothAlpha, orientationData.alpha, SMOOTHING_FACTOR_ORIENTATION);
        orientationData.smoothBeta = lerp(orientationData.smoothBeta, orientationData.beta, SMOOTHING_FACTOR_ORIENTATION);
        orientationData.smoothGamma = lerp(orientationData.smoothGamma, orientationData.gamma, SMOOTHING_FACTOR_ORIENTATION);

        // Only update camera if significant movement, or always apply smoothing if it's small
        if (Math.abs(newAlpha - orientationData.smoothAlpha) > ORIENTATION_THRESHOLD ||
            Math.abs(newBeta - orientationData.smoothBeta) > ORIENTATION_THRESHOLD ||
            Math.abs(newGamma - orientationData.smoothGamma) > ORIENTATION_THRESHOLD) {

            updateCameraFromOrientation();
        } else {
            // Still apply smoothing even for small movements to keep it fluid
            updateCameraFromOrientation();
        }
    }

    function lerp(start, end, factor) {
        return start + (end - start) * factor;
    }

    function updateCameraFromOrientation() {
        if (!deviceOrientationEnabled) return;

        let alpha = orientationData.smoothAlpha - orientationCalibration.alpha;
        let gamma = orientationData.smoothGamma - orientationCalibration.gamma;

        alpha = normalizeAngle(alpha);
        gamma = Math.max(-90, Math.min(90, gamma));

        const alphaRad = THREE.MathUtils.degToRad(alpha);
        const betaRad = THREE.MathUtils.degToRad(orientationData.smoothBeta - orientationCalibration.beta);
        const gammaRad = THREE.MathUtils.degToRad(gamma);

        camera.rotation.order = 'YXZ';
        camera.rotation.y = alphaRad;
        camera.rotation.x = betaRad;
        camera.rotation.z = -gammaRad * 0.2; // Keep some roll effect
    }

    function normalizeAngle(angle) {
        while (angle > 180) angle -= 360;
        while (angle < -180) angle += 360;
        return angle;
    }

    function calibrateOrientation() {
        if (!deviceOrientationEnabled) {
            alert('‚ö†Ô∏è Gyroscope non disponible pour la calibration');
            return;
        }

        orientationCalibration = {
            alpha: orientationData.alpha,
            beta: orientationData.beta,
            gamma: orientationData.gamma,
            isCalibrated: true
        };

        console.log('üéØ Orientation calibr√©e:', orientationCalibration);

        const btn = document.getElementById('calibrate');
        const originalText = btn.textContent;
        btn.textContent = '‚úÖ Calibr√©';
        btn.style.background = 'linear-gradient(45deg, #2ed573, #1e90ff)';

        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '';
        }, 2000);
    }

    function toggleVRMode() {
        const vrToggle = document.getElementById('vrToggle');
        const info = document.getElementById('info');
        const controls = document.getElementById('controls');
        const vrOverlay = document.getElementById('vrOverlay');
        const movementIndicator = document.getElementById('movement-indicator');
        const scoreDisplay = document.getElementById('score-display');

        isVRMode = !isVRMode;

        if (isVRMode) {
            console.log('ü•Ω Activation du mode VR');
            vrToggle.textContent = 'üëÅÔ∏è Mode Normal';
            vrToggle.classList.add('active');
            info.style.display = 'none';
            controls.style.display = 'none';
            vrOverlay.style.display = 'block';
            movementIndicator.style.display = 'block';
            scoreDisplay.style.display = 'block'; // Show score in VR

            if (!isFullscreen) {
                requestFullscreen();
            }

            setTimeout(() => {
                vrOverlay.style.display = 'none';
            }, 3000);

            isAutoMoving = true;
            updateMovementIndicator();
        } else {
            console.log('üëÅÔ∏è Retour au mode normal');
            vrToggle.textContent = 'ü•Ω Mode VR';
            vrToggle.classList.remove('active');
            info.style.display = 'block';
            controls.style.display = 'flex';
            vrOverlay.style.display = 'none';
            movementIndicator.style.display = 'none';
            scoreDisplay.style.display = 'none'; // Hide score in normal mode

            renderer.setScissorTest(false);
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);

            isAutoMoving = false;
        }

        updateVRStatus(isVRMode);
    }

    function renderStereo() {
        if (!isVRMode) {
            renderer.render(scene, camera);
            return;
        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        const eyeSeparation = 0.032;

        renderer.setScissorTest(true);

        // Left eye
        renderer.setScissor(0, 0, width / 2, height);
        renderer.setViewport(0, 0, width / 2, height);
        camera.position.x -= eyeSeparation;
        renderer.render(scene, camera);

        // Right eye
        renderer.setScissor(width / 2, 0, width / 2, height);
        renderer.setViewport(width / 2, 0, width / 2, height);
        camera.position.x += eyeSeparation * 2;
        renderer.render(scene, camera);

        // Reset camera position for next frame
        camera.position.x -= eyeSeparation;
    }

    function resetCameraView() {
        console.log('üéØ Remise √† z√©ro de la vue');
        camera.position.set(0, PLAYER_HEIGHT * currentScale, 5); // Reset to initial player height, scaled
        camera.rotation.set(0, 0, 0);
        calibrateOrientation();
    }

    function toggleFullscreen() {
        if (!isFullscreen) {
            requestFullscreen();
        } else {
            exitFullscreen();
        }
    }

    function requestFullscreen() {
        const element = document.documentElement;
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

        if (isIOS) {
            if (document.body.webkitRequestFullscreen) {
                document.body.webkitRequestFullscreen();
            } else if (document.body.webkitEnterFullscreen) {
                document.body.webkitEnterFullscreen();
            }

            if (window.screen && window.screen.orientation && window.screen.orientation.lock) {
                window.screen.orientation.lock('landscape').catch(e => {
                    console.warn('Impossible de verrouiller l\'orientation:', e);
                });
            }
        } else {
            const requestMethod = element.requestFullscreen ||
                element.webkitRequestFullscreen ||
                element.mozRequestFullScreen ||
                element.msRequestFullscreen;

            if (requestMethod) {
                requestMethod.call(element);
            }
        }
    }

    function exitFullscreen() {
        const exitMethod = document.exitFullscreen ||
            document.webkitExitFullscreen ||
            document.mozCancelFullScreen ||
            document.msExitFullscreen;

        if (exitMethod) {
            exitMethod.call(document);
        }
    }

    function updateGyroStatus(active) {
        const status = document.getElementById('gyro-status');
        if (status) {
            status.className = active ? 'status-dot active' : 'status-dot';
        }
    }

    function updateVRStatus(active) {
        const status = document.getElementById('vr-status');
        if (status) {
            status.className = active ? 'status-dot active' : 'status-dot';
        }
    }

    function createCube(isInitial = false) {
        const size = Math.random() * 1.5 + 0.5;
        const geometry = new THREE.BoxGeometry(size, size, size);

        const material = new THREE.MeshPhongMaterial({
            color: colors[Math.floor(Math.random() * colors.length)],
            transparent: true,
            opacity: 0.8,
            shininess: 100
        });

        const cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true;
        cube.receiveShadow = true;

        cube.position.set(
            (Math.random() - 0.5) * 40,
            size / 2, // Place on the ground
            (Math.random() - 0.5) * 40
        );

        // Ensure new object doesn't spawn too close to camera
        const minSpawnDistance = 5;
        while (camera.position.distanceTo(cube.position) < minSpawnDistance) {
            cube.position.set(
                (Math.random() - 0.5) * 40,
                size / 2,
                (Math.random() - 0.5) * 40
            );
        }


        cube.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
        );

        cube.userData = {
            originalColor: material.color.getHex(),
            rotationSpeed: {
                x: (Math.random() - 0.5) * 0.02,
                y: (Math.random() - 0.5) * 0.02,
                z: (Math.random() - 0.5) * 0.02
            },
            isMovable: true,
            isCollectible: true, // Mark as collectible
            velocity: new THREE.Vector3(), // For collision response
            type: 'cube'
        };

        cubes.push(cube);
        movableObjects.push(cube);
        scene.add(cube);
    }

    function createSphere(isInitial = false) {
        const radius = Math.random() * 1.2 + 0.3;
        const geometry = new THREE.SphereGeometry(radius, 16, 16);

        const material = new THREE.MeshPhongMaterial({
            color: colors[Math.floor(Math.random() * colors.length)],
            transparent: true,
            opacity: 0.7,
            emissive: colors[Math.floor(Math.random() * colors.length)],
            emissiveIntensity: 0.2,
            shininess: 150
        });

        const sphere = new THREE.Mesh(geometry, material);
        sphere.castShadow = true;
        sphere.receiveShadow = true;

        sphere.position.set(
            (Math.random() - 0.5) * 35,
            radius, // Place on the ground
            (Math.random() - 0.5) * 35
        );

        // Ensure new object doesn't spawn too close to camera
        const minSpawnDistance = 5;
        while (camera.position.distanceTo(sphere.position) < minSpawnDistance) {
            sphere.position.set(
                (Math.random() - 0.5) * 35,
                radius,
                (Math.random() - 0.5) * 35
            );
        }

        sphere.userData = {
            originalColor: material.color.getHex(),
            originalEmissive: material.emissive.getHex(),
            pulseSpeed: Math.random() * 0.05 + 0.02,
            isMovable: true,
            isCollectible: true, // Mark as collectible
            velocity: new THREE.Vector3(), // For collision response
            type: 'sphere'
        };

        spheres.push(sphere);
        movableObjects.push(sphere);
        scene.add(sphere);
    }

    function respawnObject(type) {
        if (type === 'cube') {
            createCube();
        } else if (type === 'sphere') {
            createSphere();
        }
    }

    function createParticleSystem() {
        const particleCount = 300;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            positions[i3] = (Math.random() - 0.5) * 120;
            positions[i3 + 1] = Math.random() * 60;
            positions[i3 + 2] = (Math.random() - 0.5) * 120;

            const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 1.5,
            transparent: true,
            opacity: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        particles.push(particleSystem);
    }

    function createEnvironment() {
        const gridGeometry = new THREE.PlaneGeometry(120, 120, 60, 60);
        const gridMaterial = new THREE.MeshPhongMaterial({
            color: 0x333366,
            wireframe: true,
            transparent: true,
            opacity: 0.2,
            emissive: 0x000000,
            emissiveIntensity: 0
        });

        floorMesh = new THREE.Mesh(gridGeometry, gridMaterial);
        floorMesh.rotation.x = -Math.PI / 2;
        floorMesh.position.y = 0;
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);
        originalFloorColor = new THREE.Color(0x333366);

        const starsGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(1500 * 3);
        const starColors = new Float32Array(1500 * 3);

        for (let i = 0; i < 1500; i++) {
            const i3 = i * 3;

            starPositions[i3] = (Math.random() - 0.5) * 300;
            starPositions[i3 + 1] = Math.random() * 150 + 20;
            starPositions[i3 + 2] = (Math.random() - 0.5) * 300;

            const intensity = Math.random();
            starColors[i3] = intensity;
            starColors[i3 + 1] = intensity;
            starColors[i3 + 2] = intensity;
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));

        const starsMaterial = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 0.9,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
    }

    function setupEventListeners() {
        window.addEventListener('resize', onWindowResize);

        let lastTouchTime = 0;
        window.addEventListener('touchend', (event) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTouchTime;

            if (isVRMode) {
                // Double tap to exit VR
                if (tapLength < 500 && tapLength > 0) {
                    toggleVRMode();
                } else {
                    // Single tap to start/stop movement
                    isAutoMoving = !isAutoMoving;
                    updateMovementIndicator();

                    // In VR, check for intersections for collection on single tap
                    checkIntersection(event);
                }
            } else {
                // Normal behavior (click/tap) if not in VR mode
                if (event.touches && event.touches.length === 1) {
                    const touch = event.touches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    checkIntersection(event); // Pass event to check click vs touch
                } else if (!event.touches) { // For desktop mouse clicks
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    checkIntersection(event); // Pass event
                }
            }
            lastTouchTime = currentTime;
        });

        window.addEventListener('orientationchange', () => {
            console.log('üì± Changement d\'orientation');
            setTimeout(detectScreenOrientation, 300);
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('‚è∏Ô∏è Application en arri√®re-plan');
            } else {
                console.log('‚ñ∂Ô∏è Application au premier plan');
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);

        frameCount++;
        const currentTime = performance.now();
        if (currentTime - lastTime >= 1000) {
            console.log(`üìä FPS: ${frameCount}`);
            frameCount = 0;
            lastTime = currentTime;
        }

        // Apply object velocities and damping
        movableObjects.forEach(object => {
            if (object.userData.velocity && object.userData.velocity.lengthSq() > 0.0001) {
                object.position.add(object.userData.velocity);
                object.userData.velocity.multiplyScalar(OBJECT_DAMPING); // Apply damping

                // Ensure objects stay on the ground
                if (object.geometry.type === "BoxGeometry") {
                    object.position.y = object.geometry.parameters.height / 2 * object.scale.y;
                } else if (object.geometry.type === "SphereGeometry") {
                    object.position.y = object.geometry.parameters.radius * object.scale.y;
                }
            }
        });

        // Mouvement automatique si activ√© et en mode VR
        if (isVRMode && isAutoMoving) {
            moveCameraForward();
        }

        render();
    }

    function moveCameraForward() {
        const oldCameraPosition = camera.position.clone();

        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);
        direction.y = 0;
        direction.normalize();

        const targetCameraPosition = camera.position.clone().addScaledVector(direction, MOVEMENT_SPEED);

        // Smoothly move camera towards target position
        camera.position.lerp(targetCameraPosition, SMOOTHING_FACTOR_MOVEMENT);
        camera.position.y = PLAYER_HEIGHT * currentScale; // Maintain scaled player height

        // Check for collisions with movable objects
        movableObjects.forEach(object => {
            // Get effective radius for collision
            let objectCollisionRadius;
            if (object.geometry.type === "BoxGeometry") {
                objectCollisionRadius = Math.sqrt(
                    (object.geometry.parameters.width * object.scale.x / 2) ** 2 +
                    (object.geometry.parameters.depth * object.scale.z / 2) ** 2
                );
            } else if (object.geometry.type === "SphereGeometry") {
                objectCollisionRadius = object.geometry.parameters.radius * object.scale.x;
            }

            const distance = camera.position.distanceTo(object.position);
            const combinedRadius = (PLAYER_RADIUS * currentScale) + objectCollisionRadius; // Player radius scales

            if (distance < combinedRadius) {
                const collisionNormal = camera.position.clone().sub(object.position).normalize();

                // Push object away if it's movable
                if (object.userData.isMovable) {
                    const overlap = combinedRadius - distance;
                    const pushVector = collisionNormal.clone().multiplyScalar(-overlap * OBJECT_PUSH_FORCE);
                    object.userData.velocity.add(pushVector);
                }

                // Adjust camera position to prevent penetration
                const cameraAdjust = collisionNormal.clone().multiplyScalar(combinedRadius - distance);
                camera.position.add(cameraAdjust);
            }
        });


        // Check for "step" to trigger floor effect
        if (camera.position.distanceTo(lastCameraPosition) > STEP_DISTANCE_THRESHOLD) {
            triggerFloorEffect(camera.position.clone());
            lastCameraPosition.copy(camera.position);
        }
    }


    function triggerFloorEffect(position) {
        if (!floorMesh) return;

        const originalEmissive = floorMesh.material.emissive.clone();
        const originalEmissiveIntensity = floorMesh.material.emissiveIntensity;

        const flashColor = new THREE.Color(0x88CCFF);
        const flashIntensity = 2.0;

        const startTime = Date.now();

        function animateFloorEffect() {
            const elapsedTime = Date.now() - startTime;
            const progress = elapsedTime / FLOOR_EFFECT_DURATION;

            if (progress < 1) {
                floorMesh.material.emissive.lerpColors(flashColor, originalEmissive, progress);
                floorMesh.material.emissiveIntensity = lerp(flashIntensity, originalEmissiveIntensity, progress);

                if (progress > 0.5 && Math.random() < 0.2) {
                    createRisingParticles(position);
                }

                requestAnimationFrame(animateFloorEffect);
            } else {
                floorMesh.material.emissive.copy(originalEmissive);
                floorMesh.material.emissiveIntensity = originalEmissiveIntensity;
            }
        }
        animateFloorEffect();
    }

    function createRisingParticles(originPosition) {
        const particleCount = 15;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colorsArray = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const lifetimes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            positions[i3] = originPosition.x + (Math.random() - 0.5) * 0.5;
            positions[i3 + 1] = 0.1;
            positions[i3 + 2] = originPosition.z + (Math.random() - 0.5) * 0.5;

            const intensity = Math.random();
            colorsArray[i3] = intensity;
            colorsArray[i3 + 1] = intensity;
            colorsArray[i3 + 2] = intensity;

            velocities[i3] = (Math.random() - 0.5) * 0.01;
            velocities[i3 + 1] = Math.random() * 0.05 + 0.01;
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.01;

            lifetimes[i] = Math.random() * 1.5 + 0.5;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
        geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));

        const material = new THREE.PointsMaterial({
            size: 1.0,
            transparent: true,
            opacity: 1.0,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const risingParticles = new THREE.Points(geometry, material);
        scene.add(risingParticles);

        const effectStartTime = clock.getElapsedTime();

        function animateRisingParticles() {
            const currentTime = clock.getElapsedTime();
            const positions = risingParticles.geometry.attributes.position.array;
            const velocities = risingParticles.geometry.attributes.velocity.array;
            const lifetimes = risingParticles.geometry.attributes.lifetime.array;
            const colors = risingParticles.geometry.attributes.color.array;

            let particlesAlive = 0;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const particleLifetime = lifetimes[i];
                const age = currentTime - effectStartTime;

                if (age < particleLifetime) {
                    positions[i3] += velocities[i3];
                    positions[i3 + 1] += velocities[i3 + 1];
                    positions[i3 + 2] += velocities[i3 + 2];

                    const fadeProgress = age / particleLifetime;
                    material.opacity = 1.0 - fadeProgress;
                    particlesAlive++;
                } else {
                    positions[i3] = positions[i3 + 1] = positions[i3 + 2] = 10000;
                }
            }

            risingParticles.geometry.attributes.position.needsUpdate = true;
            risingParticles.material.opacity = material.opacity;

            if (particlesAlive > 0) {
                requestAnimationFrame(animateRisingParticles);
            } else {
                scene.remove(risingParticles);
                geometry.dispose();
                material.dispose();
            }
        }
        animateRisingParticles();
    }


    function render() {
        const time = clock.getElapsedTime();

        cubes.forEach((cube) => {
            const userData = cube.userData;
            if (userData.velocity.lengthSq() < 0.01) {
                cube.rotation.x += userData.rotationSpeed.x;
                cube.rotation.y += userData.rotationSpeed.y;
                cube.rotation.z += userData.rotationSpeed.z;
            }
        });

        spheres.forEach((sphere) => {
            const userData = sphere.userData;
            const scale = 1 + Math.sin(time * userData.pulseSpeed) * 0.15;
            sphere.scale.setScalar(scale);
            const emissiveIntensity = 0.1 + Math.sin(time * userData.pulseSpeed * 2) * 0.1;
            sphere.material.emissiveIntensity = emissiveIntensity;
        });

        particles.forEach(particleSystem => {
            particleSystem.rotation.y += 0.0005;
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 1; i < positions.length; i += 3) {
                positions[i] += Math.sin(time * 0.001 + positions[i] * 0.01) * 0.02;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        });

        renderStereo();
    }

    // Modified checkIntersection for collecting objects
    function checkIntersection(event) {
        // If not in VR mode, or if event is a double tap (which means exiting VR), don't collect
        if (!isVRMode || (event && event.touches && event.touches.length > 1)) {
            // For desktop clicks or non-VR single taps, still allow highlights but no collection
            // if (event.touches && event.touches.length === 1) { // desktop
            //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            //     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            // } else if (!event.touches) { // mobile
            //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            //     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            // }
            // raycaster.setFromCamera(mouse, camera);
            // const intersects = raycaster.intersectObjects([...cubes, ...spheres]);
            // if (intersects.length > 0) {
            //     const object = intersects[0].object;
            //     createSelectionEffect(object.position); // Still show highlight
            // }
            return; // Exit if not in VR or double tap
        }

        // In VR mode, raycast from center of screen (or a slightly offset point for VR look-at interaction)
        // For simplicity, we can use a fixed point in the camera's view direction or just a small offset
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); // Raycast from center of camera view

        const intersects = raycaster.intersectObjects(movableObjects); // Only check movable objects

        if (intersects.length > 0) {
            const object = intersects[0].object;

            if (object.userData.isCollectible) {
                // Collect the object
                collectObject(object);
            }
        }
    }

    function collectObject(object) {
        console.log('Collected:', object.userData.type);

        // Remove from scene
        scene.remove(object);

        // Remove from tracking arrays
        const cubeIndex = cubes.indexOf(object);
        if (cubeIndex > -1) {
            cubes.splice(cubeIndex, 1);
        }
        const sphereIndex = spheres.indexOf(object);
        if (sphereIndex > -1) {
            spheres.splice(sphereIndex, 1);
        }
        const movableIndex = movableObjects.indexOf(object);
        if (movableIndex > -1) {
            movableObjects.splice(movableIndex, 1);
        }

        // Dispose geometry and material to free up memory
        if (object.geometry) object.geometry.dispose();
        if (object.material) object.material.dispose();

        // Increment score
        collectedCount++;
        updateScoreDisplay();

        // Grow player
        growPlayer();

        // Respawn a new object of the same type
        respawnObject(object.userData.type);

        // Visual feedback for collection (optional, similar to selection effect but shorter)
        createCollectionEffect(object.position);
    }

    function updateScoreDisplay() {
        document.getElementById('collected-count').textContent = collectedCount;
    }

    function growPlayer() {
        // Increase player scale gradually
        currentScale += GROW_FACTOR_PER_COLLECTIBLE;
        camera.scale.setScalar(currentScale);
        camera.position.y = PLAYER_HEIGHT * currentScale; // Adjust camera height
        console.log('Player scaled to:', currentScale.toFixed(2));
    }


    function createSelectionEffect(position) {
        const particleCount = 20;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = position.x + (Math.random() - 0.5) * 2;
            positions[i + 1] = position.y + (Math.random() - 0.5) * 2;
            positions[i + 2] = position.z + (Math.random() - 0.5) * 2;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 3,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending
        });

        const effect = new THREE.Points(geometry, material);
        scene.add(effect);

        const startTime = performance.now();
        const duration = 1000;

        function animateEffect() {
            const elapsed = performance.now() - startTime;
            const progress = elapsed / duration;

            if (progress < 1) {
                material.opacity = 1 - progress;
                effect.scale.setScalar(1 + progress * 2);
                requestAnimationFrame(animateEffect);
            } else {
                scene.remove(effect);
                geometry.dispose();
                material.dispose();
            }
        }

        animateEffect();
    }

    function createCollectionEffect(position) {
        const particleCount = 30; // More particles for collection
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colorsArray = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;

            positions[i3] = position.x;
            positions[i3 + 1] = position.y;
            positions[i3 + 2] = position.z;

            const color = new THREE.Color(0x00FF00); // Greenish effect for collection
            colorsArray[i3] = color.r;
            colorsArray[i3 + 1] = color.g;
            colorsArray[i3 + 2] = color.b;

            // Random velocities to spread outwards and upwards
            velocities[i3] = (Math.random() - 0.5) * 0.1;
            velocities[i3 + 1] = Math.random() * 0.1 + 0.05; // Stronger upward movement
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
        geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));


        const material = new THREE.PointsMaterial({
            size: 2,
            transparent: true,
            opacity: 1,
            vertexColors: true,
            blending: THREE.AdditiveBlending
        });

        const effect = new THREE.Points(geometry, material);
        scene.add(effect);

        const startTime = performance.now();
        const duration = 800; // Shorter duration for collection effect

        function animateCollectionEffect() {
            const elapsed = performance.now() - startTime;
            const progress = elapsed / duration;

            if (progress < 1) {
                const currentPositions = effect.geometry.attributes.position.array;
                const currentVelocities = effect.geometry.attributes.velocity.array;
                for (let i = 0; i < particleCount * 3; i += 3) {
                    currentPositions[i] += currentVelocities[i];
                    currentPositions[i + 1] += currentVelocities[i + 1];
                    currentPositions[i + 2] += currentVelocities[i + 2];
                }
                effect.geometry.attributes.position.needsUpdate = true;
                material.opacity = 1 - progress;
                requestAnimationFrame(animateCollectionEffect);
            } else {
                scene.remove(effect);
                geometry.dispose();
                material.dispose();
            }
        }
        animateCollectionEffect();
    }


    function detectScreenOrientation() {
        if (window.innerHeight > window.innerWidth) {
            if (screenOrientation !== 'portrait') {
                screenOrientation = 'portrait';
                console.log('üì± Orientation: portrait');
                document.getElementById('orientation-warning').style.display = 'flex';
            }
        } else {
            if (screenOrientation !== 'landscape') {
                screenOrientation = 'landscape';
                console.getElementById('orientation-warning').style.display = 'none';
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        console.log('üì± Redimensionnement:', window.innerWidth, 'x', window.innerHeight);

        detectScreenOrientation();
    }

    updateGyroStatus(false);
    updateVRStatus(false);
    updateFullscreenStatus();
    document.getElementById('score-display').style.display = 'none'; // Hide score initially

    console.log('üéÆ Application VR pr√™te !');
</script>
</body>
</html>